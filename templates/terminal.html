<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCO Unix System V/386 - Modem Simulator</title>

    <!-- xterm.js CSS -->
    <link rel="stylesheet" href="{{ url_for('static', filename='css/xterm.css') }}" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        #header {
            background-color: #1a1a1a;
            color: #00ff00;
            padding: 10px 20px;
            border-bottom: 2px solid #00ff00;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #header h1 {
            font-size: 16px;
            font-weight: bold;
            color: #00ff00;
        }

        #status {
            font-size: 12px;
            color: #ffff00;
        }

        #terminal-container {
            flex: 1;
            padding: 10px;
            overflow: hidden;
            position: relative;
            min-height: 400px;
            z-index: 1;
            background-color: #000;
        }

        #terminal {
            width: 100%;
            height: 100%;
            position: relative;
            z-index: 2;
        }

        .xterm {
            height: 100%;
            padding: 5px;
        }

        .xterm-viewport {
            background-color: #000 !important;
        }

        .xterm-screen {
            background-color: #000 !important;
        }

        /* Custom scrollbar for webkit browsers */
        .xterm-viewport::-webkit-scrollbar {
            width: 10px;
        }

        .xterm-viewport::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .xterm-viewport::-webkit-scrollbar-thumb {
            background: #00ff00;
            border-radius: 5px;
        }

        .xterm-viewport::-webkit-scrollbar-thumb:hover {
            background: #00cc00;
        }

        /* Loading screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #00ff00;
        }

        #loading h2 {
            font-size: 24px;
            margin-bottom: 20px;
        }

        #loading .spinner {
            border: 4px solid #1a1a1a;
            border-top: 4px solid #00ff00;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <h2>SCO UNIX SYSTEM V/386</h2>
        <div class="spinner"></div>
        <p style="margin-top: 20px;">Initializing modem connection...</p>
    </div>

    <!-- Header -->
    <div id="header">
        <h1>üìü SCO Unix System V/386 - Modem Simulator (Web Terminal)</h1>
        <div id="status">‚óè Connected</div>
    </div>

    <!-- Terminal Container -->
    <div id="terminal-container">
        <div id="terminal"></div>
    </div>

    <!-- Socket.IO -->
    <script src="{{ url_for('static', filename='js/socket.io.min.js') }}"></script>

    <!-- xterm.js -->
    <script src="{{ url_for('static', filename='js/xterm.js') }}"></script>
    <script src="{{ url_for('static', filename='js/xterm-addon-fit.js') }}"></script>
    <script src="{{ url_for('static', filename='js/xterm-addon-web-links.js') }}"></script>

    <script>
        // Verify xterm.js is loaded
        console.log('[INIT] xterm.js loaded:', typeof Terminal !== 'undefined');
        console.log('[INIT] FitAddon loaded:', typeof FitAddon !== 'undefined');
        console.log('[INIT] WebLinksAddon loaded:', typeof WebLinksAddon !== 'undefined');

        // Initialize xterm.js
        const term = new Terminal({
            cursorBlink: true,
            cursorStyle: 'block',
            fontSize: 14,
            fontFamily: '"Courier New", Courier, monospace',
            theme: {
                background: '#000000',
                foreground: '#00ff00',
                cursor: '#00ff00',
                cursorAccent: '#000000',
                black: '#000000',
                red: '#ff0000',
                green: '#00ff00',
                yellow: '#ffff00',
                blue: '#0000ff',
                magenta: '#ff00ff',
                cyan: '#00ffff',
                white: '#ffffff',
                brightBlack: '#666666',
                brightRed: '#ff6666',
                brightGreen: '#66ff66',
                brightYellow: '#ffff66',
                brightBlue: '#6666ff',
                brightMagenta: '#ff66ff',
                brightCyan: '#66ffff',
                brightWhite: '#ffffff'
            },
            cols: 80,
            rows: 24,
            scrollback: 1000
        });

        // Add fit addon
        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);

        // Add web links addon
        const webLinksAddon = new WebLinksAddon.WebLinksAddon();
        term.loadAddon(webLinksAddon);

        // Open terminal
        const terminalElement = document.getElementById('terminal');
        console.log('[INIT] Terminal element:', terminalElement);
        console.log('[INIT] Terminal element dimensions:', terminalElement ? `${terminalElement.clientWidth}x${terminalElement.clientHeight}` : 'N/A');

        try {
            term.open(terminalElement);
            console.log('[INIT] Terminal.open() called successfully');

            // Debug: Check what elements were created
            setTimeout(() => {
                console.log('[INIT] Terminal element HTML:', terminalElement.innerHTML.substring(0, 500));
                console.log('[INIT] Terminal element children:', terminalElement.children);
                const allElements = terminalElement.querySelectorAll('*');
                console.log('[INIT] All child elements count:', allElements.length);
                console.log('[INIT] Element types:', Array.from(allElements).map(el => el.tagName).join(', '));
            }, 100);
        } catch (e) {
            console.error('[INIT] Error opening terminal:', e);
        }

        // DON'T fit immediately - terminal is behind loading screen
        // fitAddon.fit();
        console.log('[INIT] Terminal opened, size:', term.cols, 'x', term.rows);

        // Write a test message to verify terminal is working
        term.write('Terminal initialized successfully\r\n');
        console.log('[INIT] Test message written to terminal');

        // Debug: Check if xterm canvas was created
        setTimeout(() => {
            const canvas = terminalElement.querySelector('canvas');
            const xtermElement = terminalElement.querySelector('.xterm');
            const xtermScreen = terminalElement.querySelector('.xterm-screen');

            console.log('[DEBUG] Canvas element:', canvas);
            console.log('[DEBUG] Canvas dimensions:', canvas ? `${canvas.width}x${canvas.height}` : 'N/A');
            console.log('[DEBUG] .xterm element:', xtermElement);
            console.log('[DEBUG] .xterm-screen element:', xtermScreen);

            if (xtermElement) {
                const computedStyle = window.getComputedStyle(xtermElement);
                console.log('[DEBUG] .xterm computed height:', computedStyle.height);
                console.log('[DEBUG] .xterm computed width:', computedStyle.width);
                console.log('[DEBUG] .xterm computed display:', computedStyle.display);
            }

            if (canvas) {
                const canvasStyle = window.getComputedStyle(canvas);
                console.log('[DEBUG] Canvas computed height:', canvasStyle.height);
                console.log('[DEBUG] Canvas computed width:', canvasStyle.width);
                console.log('[DEBUG] Canvas visibility:', canvasStyle.visibility);
                console.log('[DEBUG] Canvas opacity:', canvasStyle.opacity);
            }
        }, 500);

        // Handle window resize
        window.addEventListener('resize', () => {
            fitAddon.fit();
            socket.emit('resize', {
                cols: term.cols,
                rows: term.rows
            });
        });

        // Input buffer
        let currentLine = '';

        // Socket.IO connection
        // Use polling only to avoid WebSocket WSGI errors
        const socket = io({
            transports: ['polling'],
            upgrade: false
        });

        console.log('[INIT] Socket.IO initialized (polling mode)');

        socket.on('connect', () => {
            console.log('[SOCKET] Connected to server');
            document.getElementById('status').innerHTML = '‚óè Connected';
            document.getElementById('status').style.color = '#00ff00';

            // Hide loading screen after receiving first output
            console.log('[SOCKET] Connection established, waiting for output...');
        });

        socket.on('disconnect', () => {
            console.log('[SOCKET] Disconnected from server');
            document.getElementById('status').innerHTML = '‚óã Disconnected';
            document.getElementById('status').style.color = '#ff0000';
            term.write('\r\n\r\n=== Connection lost. Please refresh the page. ===\r\n');
        });

        socket.on('connected', (data) => {
            console.log('[SOCKET] Server response:', data.data);
        });

        let outputReceived = false;
        socket.on('output', (data) => {
            console.log('[OUTPUT] Received:', data.data.substring(0, 50));
            console.log('[OUTPUT] Full data length:', data.data.length);
            console.log('[OUTPUT] Terminal cols:', term.cols, 'rows:', term.rows);

            // Write to terminal
            try {
                term.write(data.data);
                console.log('[OUTPUT] Successfully wrote to terminal');
            } catch (e) {
                console.error('[OUTPUT] Error writing to terminal:', e);
            }

            // Hide loading screen on first output
            if (!outputReceived) {
                outputReceived = true;
                console.log('[UI] First output received, hiding loading screen');
                setTimeout(() => {
                    document.getElementById('loading').classList.add('hidden');
                    console.log('[UI] Loading screen hidden');
                    // Force terminal refresh
                    setTimeout(() => {
                        fitAddon.fit();
                        term.focus();
                        term.scrollToBottom();
                        term.refresh(0, term.rows - 1);
                        console.log('[UI] Terminal refitted, focused, and refreshed');
                        console.log('[UI] Terminal buffer line count:', term.buffer.active.length);
                    }, 200);
                }, 100);
            }
        });

        // Handle terminal input
        term.onData((data) => {
            const code = data.charCodeAt(0);

            // Handle Enter key (CR or LF)
            if (code === 13 || code === 10) {
                term.write('\r\n');
                console.log('[INPUT] Sending line:', currentLine);
                socket.emit('input', { data: currentLine });
                currentLine = '';
            }
            // Handle Backspace
            else if (code === 127 || code === 8) {
                if (currentLine.length > 0) {
                    currentLine = currentLine.slice(0, -1);
                    term.write('\b \b');
                }
            }
            // Handle Ctrl+C
            else if (code === 3) {
                term.write('^C\r\n');
                socket.emit('input', { data: '' });
                currentLine = '';
            }
            // Handle Ctrl+D
            else if (code === 4) {
                term.write('^D\r\n');
                socket.emit('input', { data: 'exit' });
                currentLine = '';
            }
            // Handle Tab
            else if (code === 9) {
                // Tab completion could be implemented here
                term.write('    ');
            }
            // Regular characters
            else if (code >= 32 && code < 127) {
                currentLine += data;
                term.write(data);
            }
        });

        // Focus terminal on load
        term.focus();

        // Force initial render after a short delay to ensure everything is loaded
        setTimeout(() => {
            console.log('[INIT] Forcing initial terminal render');
            term.clear();
            term.write('===Terminal Ready===\r\n');
            fitAddon.fit();
            term.refresh(0, term.rows - 1);
            console.log('[INIT] Initial render complete, size:', term.cols, 'x', term.rows);
        }, 1000);

        // Prevent context menu
        document.getElementById('terminal').addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        // Keep terminal focused
        document.addEventListener('click', () => {
            term.focus();
        });

        // Show info message
        console.log('SCO Unix System V/386 Modem Simulator');
        console.log('Web Terminal Interface using xterm.js');
        console.log('Default login: root / root');
    </script>
</body>
</html>
