<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCO Unix System V/386 - VT100 Terminal</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            color: #00ff00;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        #header {
            background-color: #1a1a1a;
            color: #00ff00;
            padding: 10px 20px;
            border-bottom: 2px solid #00ff00;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        #header h1 {
            font-size: 16px;
            font-weight: bold;
        }

        #status {
            font-size: 12px;
        }

        #status.connected {
            color: #00ff00;
        }

        #status.disconnected {
            color: #ff0000;
        }

        #status.connecting {
            color: #ffff00;
        }

        /* Terminal Container */
        #terminal-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: #000;
            padding: 10px;
        }

        /* VT100 Terminal Display */
        #terminal-screen {
            font-family: 'Courier New', Courier, monospace;
            font-size: 16px;
            line-height: 1.2;
            white-space: pre;
            color: #00ff00;
            background-color: #000;
            flex: 1;
            overflow: hidden;
            position: relative;
            cursor: default;
            user-select: none;
        }

        /* Cursor styles */
        .cursor-block {
            display: inline-block;
            background-color: #00ff00;
            color: #000;
            animation: blink-block 1s infinite;
        }

        .cursor-underline {
            text-decoration: underline;
            text-decoration-color: #00ff00;
            text-decoration-thickness: 2px;
        }

        @keyframes blink-block {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0.3; }
        }

        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #00ff00;
        }

        #loading h2 {
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
        }

        #loading .spinner {
            border: 4px solid #1a1a1a;
            border-top: 4px solid #00ff00;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        #loading p {
            margin-top: 20px;
            font-size: 14px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        /* ANSI color classes */
        .ansi-black { color: #000000; }
        .ansi-red { color: #ff0000; }
        .ansi-green { color: #00ff00; }
        .ansi-yellow { color: #ffff00; }
        .ansi-blue { color: #0000ff; }
        .ansi-magenta { color: #ff00ff; }
        .ansi-cyan { color: #00ffff; }
        .ansi-white { color: #ffffff; }
        .ansi-bright-black { color: #555555; }
        .ansi-bright-red { color: #ff5555; }
        .ansi-bright-green { color: #55ff55; }
        .ansi-bright-yellow { color: #ffff55; }
        .ansi-bright-blue { color: #5555ff; }
        .ansi-bright-magenta { color: #ff55ff; }
        .ansi-bright-cyan { color: #55ffff; }
        .ansi-bright-white { color: #ffffff; }

        .ansi-bg-black { background-color: #000000; }
        .ansi-bg-red { background-color: #ff0000; }
        .ansi-bg-green { background-color: #00ff00; }
        .ansi-bg-yellow { background-color: #ffff00; }
        .ansi-bg-blue { background-color: #0000ff; }
        .ansi-bg-magenta { background-color: #ff00ff; }
        .ansi-bg-cyan { background-color: #00ffff; }
        .ansi-bg-white { background-color: #ffffff; }

        .ansi-bold { font-weight: bold; }
        .ansi-dim { opacity: 0.5; }
        .ansi-underline { text-decoration: underline; }
        .ansi-blink { animation: blink 1s infinite; }
        .ansi-reverse { filter: invert(1); }
        .ansi-hidden { visibility: hidden; }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        /* Hidden input for mobile keyboard support */
        #hidden-input {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <h2>SCO UNIX SYSTEM V/386</h2>
        <div class="spinner"></div>
        <p>Initializing VT100 terminal...</p>
    </div>

    <!-- Header -->
    <div id="header">
        <h1>SCO Unix System V/386 - VT100 Terminal Emulator</h1>
        <div id="status" class="connecting">● Connecting...</div>
    </div>

    <!-- Terminal -->
    <div id="terminal-container">
        <div id="terminal-screen" tabindex="0"></div>
        <input type="text" id="hidden-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
    </div>

    <!-- Socket.IO -->
    <script src="{{ url_for('static', filename='js/socket.io.min.js') }}"></script>

    <script>
        /**
         * VT100 Terminal Emulator
         * Implements a classic VT100 terminal with ANSI escape sequence support
         */
        class VT100Terminal {
            constructor(containerElement) {
                this.container = containerElement;
                this.cols = 80;
                this.rows = 24;
                this.cursorX = 0;
                this.cursorY = 0;
                this.savedCursorX = 0;
                this.savedCursorY = 0;
                this.scrollTop = 0;
                this.scrollBottom = this.rows - 1;

                // Screen buffer: each cell contains {char, style}
                this.buffer = [];
                for (let i = 0; i < this.rows; i++) {
                    this.buffer[i] = [];
                    for (let j = 0; j < this.cols; j++) {
                        this.buffer[i][j] = { char: ' ', style: this.defaultStyle() };
                    }
                }

                // Current text style
                this.currentStyle = this.defaultStyle();

                // ANSI parser state
                this.parseState = 'normal';
                this.escapeBuffer = '';

                // Cursor visibility and blinking
                this.cursorVisible = true;
                this.cursorBlink = true;

                // Start cursor blink timer
                this.startCursorBlink();

                // Initial render
                this.render();
            }

            defaultStyle() {
                return {
                    fg: 'green',
                    bg: 'black',
                    bold: false,
                    dim: false,
                    underline: false,
                    blink: false,
                    reverse: false,
                    hidden: false
                };
            }

            startCursorBlink() {
                setInterval(() => {
                    this.cursorBlink = !this.cursorBlink;
                    this.render();
                }, 530); // VT100 cursor blinks at ~1.875 Hz
            }

            /**
             * Write data to the terminal
             */
            write(data) {
                for (let i = 0; i < data.length; i++) {
                    const char = data[i];

                    if (this.parseState === 'normal') {
                        this.handleNormalChar(char);
                    } else if (this.parseState === 'escape') {
                        this.handleEscapeChar(char);
                    } else if (this.parseState === 'csi') {
                        this.handleCSIChar(char);
                    }
                }

                this.render();
            }

            handleNormalChar(char) {
                const code = char.charCodeAt(0);

                if (code === 27) { // ESC
                    this.parseState = 'escape';
                    this.escapeBuffer = '';
                } else if (code === 8) { // Backspace
                    if (this.cursorX > 0) {
                        this.cursorX--;
                    }
                } else if (code === 9) { // Tab
                    this.cursorX = Math.min(this.cols - 1, (Math.floor(this.cursorX / 8) + 1) * 8);
                } else if (code === 10) { // Line Feed
                    this.lineFeed();
                } else if (code === 13) { // Carriage Return
                    this.cursorX = 0;
                } else if (code === 7) { // Bell
                    // Beep sound (ignored in web)
                } else if (code >= 32 && code < 127) { // Printable ASCII
                    this.putChar(char);
                    this.cursorX++;
                    if (this.cursorX >= this.cols) {
                        this.cursorX = 0;
                        this.lineFeed();
                    }
                }
            }

            handleEscapeChar(char) {
                if (char === '[') {
                    this.parseState = 'csi';
                    this.escapeBuffer = '';
                } else if (char === 'M') {
                    // Reverse line feed
                    if (this.cursorY > this.scrollTop) {
                        this.cursorY--;
                    } else {
                        this.scrollDown();
                    }
                    this.parseState = 'normal';
                } else if (char === '7') {
                    // Save cursor
                    this.savedCursorX = this.cursorX;
                    this.savedCursorY = this.cursorY;
                    this.parseState = 'normal';
                } else if (char === '8') {
                    // Restore cursor
                    this.cursorX = this.savedCursorX;
                    this.cursorY = this.savedCursorY;
                    this.parseState = 'normal';
                } else if (char === 'c') {
                    // Reset terminal
                    this.reset();
                    this.parseState = 'normal';
                } else {
                    this.parseState = 'normal';
                }
            }

            handleCSIChar(char) {
                const code = char.charCodeAt(0);

                if ((code >= 48 && code <= 57) || char === ';' || char === '?') {
                    // Parameter character
                    this.escapeBuffer += char;
                } else {
                    // Command character
                    this.executeCSI(this.escapeBuffer, char);
                    this.parseState = 'normal';
                }
            }

            executeCSI(params, command) {
                const args = params.split(';').map(x => parseInt(x) || 0);

                switch (command) {
                    case 'A': // Cursor Up
                        this.cursorY = Math.max(this.scrollTop, this.cursorY - (args[0] || 1));
                        break;
                    case 'B': // Cursor Down
                        this.cursorY = Math.min(this.scrollBottom, this.cursorY + (args[0] || 1));
                        break;
                    case 'C': // Cursor Forward
                        this.cursorX = Math.min(this.cols - 1, this.cursorX + (args[0] || 1));
                        break;
                    case 'D': // Cursor Back
                        this.cursorX = Math.max(0, this.cursorX - (args[0] || 1));
                        break;
                    case 'H': // Cursor Position
                    case 'f':
                        this.cursorY = Math.min(this.rows - 1, Math.max(0, (args[0] || 1) - 1));
                        this.cursorX = Math.min(this.cols - 1, Math.max(0, (args[1] || 1) - 1));
                        break;
                    case 'J': // Erase in Display
                        this.eraseDisplay(args[0] || 0);
                        break;
                    case 'K': // Erase in Line
                        this.eraseLine(args[0] || 0);
                        break;
                    case 'm': // Select Graphic Rendition
                        this.setGraphicRendition(args);
                        break;
                    case 'r': // Set Scrolling Region
                        this.scrollTop = Math.max(0, (args[0] || 1) - 1);
                        this.scrollBottom = Math.min(this.rows - 1, (args[1] || this.rows) - 1);
                        break;
                    case 's': // Save cursor position
                        this.savedCursorX = this.cursorX;
                        this.savedCursorY = this.cursorY;
                        break;
                    case 'u': // Restore cursor position
                        this.cursorX = this.savedCursorX;
                        this.cursorY = this.savedCursorY;
                        break;
                    case 'l': // Reset Mode
                        if (params === '?25') {
                            this.cursorVisible = false;
                        }
                        break;
                    case 'h': // Set Mode
                        if (params === '?25') {
                            this.cursorVisible = true;
                        }
                        break;
                }
            }

            setGraphicRendition(args) {
                if (args.length === 0 || args[0] === 0) {
                    this.currentStyle = this.defaultStyle();
                    return;
                }

                for (let i = 0; i < args.length; i++) {
                    const arg = args[i];

                    if (arg === 0) {
                        this.currentStyle = this.defaultStyle();
                    } else if (arg === 1) {
                        this.currentStyle.bold = true;
                    } else if (arg === 2) {
                        this.currentStyle.dim = true;
                    } else if (arg === 4) {
                        this.currentStyle.underline = true;
                    } else if (arg === 5) {
                        this.currentStyle.blink = true;
                    } else if (arg === 7) {
                        this.currentStyle.reverse = true;
                    } else if (arg === 8) {
                        this.currentStyle.hidden = true;
                    } else if (arg === 22) {
                        this.currentStyle.bold = false;
                        this.currentStyle.dim = false;
                    } else if (arg === 24) {
                        this.currentStyle.underline = false;
                    } else if (arg === 25) {
                        this.currentStyle.blink = false;
                    } else if (arg === 27) {
                        this.currentStyle.reverse = false;
                    } else if (arg === 28) {
                        this.currentStyle.hidden = false;
                    } else if (arg >= 30 && arg <= 37) {
                        // Foreground colors
                        const colors = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
                        this.currentStyle.fg = colors[arg - 30];
                    } else if (arg >= 40 && arg <= 47) {
                        // Background colors
                        const colors = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
                        this.currentStyle.bg = colors[arg - 40];
                    } else if (arg >= 90 && arg <= 97) {
                        // Bright foreground colors
                        const colors = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
                        this.currentStyle.fg = 'bright-' + colors[arg - 90];
                    } else if (arg >= 100 && arg <= 107) {
                        // Bright background colors
                        const colors = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
                        this.currentStyle.bg = 'bright-' + colors[arg - 100];
                    }
                }
            }

            eraseDisplay(mode) {
                if (mode === 0) { // Erase from cursor to end
                    this.eraseLine(0);
                    for (let y = this.cursorY + 1; y < this.rows; y++) {
                        for (let x = 0; x < this.cols; x++) {
                            this.buffer[y][x] = { char: ' ', style: this.defaultStyle() };
                        }
                    }
                } else if (mode === 1) { // Erase from start to cursor
                    this.eraseLine(1);
                    for (let y = 0; y < this.cursorY; y++) {
                        for (let x = 0; x < this.cols; x++) {
                            this.buffer[y][x] = { char: ' ', style: this.defaultStyle() };
                        }
                    }
                } else if (mode === 2) { // Erase entire display
                    for (let y = 0; y < this.rows; y++) {
                        for (let x = 0; x < this.cols; x++) {
                            this.buffer[y][x] = { char: ' ', style: this.defaultStyle() };
                        }
                    }
                }
            }

            eraseLine(mode) {
                if (mode === 0) { // Erase from cursor to end of line
                    for (let x = this.cursorX; x < this.cols; x++) {
                        this.buffer[this.cursorY][x] = { char: ' ', style: this.defaultStyle() };
                    }
                } else if (mode === 1) { // Erase from start of line to cursor
                    for (let x = 0; x <= this.cursorX; x++) {
                        this.buffer[this.cursorY][x] = { char: ' ', style: this.defaultStyle() };
                    }
                } else if (mode === 2) { // Erase entire line
                    for (let x = 0; x < this.cols; x++) {
                        this.buffer[this.cursorY][x] = { char: ' ', style: this.defaultStyle() };
                    }
                }
            }

            putChar(char) {
                this.buffer[this.cursorY][this.cursorX] = {
                    char: char,
                    style: Object.assign({}, this.currentStyle)
                };
            }

            lineFeed() {
                if (this.cursorY >= this.scrollBottom) {
                    this.scrollUp();
                } else {
                    this.cursorY++;
                }
            }

            scrollUp() {
                // Move lines up
                for (let y = this.scrollTop; y < this.scrollBottom; y++) {
                    this.buffer[y] = this.buffer[y + 1];
                }
                // Clear bottom line
                this.buffer[this.scrollBottom] = [];
                for (let x = 0; x < this.cols; x++) {
                    this.buffer[this.scrollBottom][x] = { char: ' ', style: this.defaultStyle() };
                }
            }

            scrollDown() {
                // Move lines down
                for (let y = this.scrollBottom; y > this.scrollTop; y--) {
                    this.buffer[y] = this.buffer[y - 1];
                }
                // Clear top line
                this.buffer[this.scrollTop] = [];
                for (let x = 0; x < this.cols; x++) {
                    this.buffer[this.scrollTop][x] = { char: ' ', style: this.defaultStyle() };
                }
            }

            reset() {
                this.cursorX = 0;
                this.cursorY = 0;
                this.scrollTop = 0;
                this.scrollBottom = this.rows - 1;
                this.currentStyle = this.defaultStyle();
                this.eraseDisplay(2);
            }

            /**
             * Render the terminal to the DOM
             */
            render() {
                let html = '';

                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        const cell = this.buffer[y][x];
                        const isCursor = (x === this.cursorX && y === this.cursorY && this.cursorVisible && this.cursorBlink);

                        let char = cell.char;
                        let classes = [];
                        let style = cell.style;

                        // Apply text styles
                        if (style.fg !== 'green') classes.push('ansi-' + style.fg);
                        if (style.bg !== 'black') classes.push('ansi-bg-' + style.bg);
                        if (style.bold) classes.push('ansi-bold');
                        if (style.dim) classes.push('ansi-dim');
                        if (style.underline) classes.push('ansi-underline');
                        if (style.blink) classes.push('ansi-blink');
                        if (style.reverse) classes.push('ansi-reverse');
                        if (style.hidden) classes.push('ansi-hidden');

                        if (isCursor) {
                            classes.push('cursor-block');
                        }

                        if (classes.length > 0) {
                            html += '<span class="' + classes.join(' ') + '">' + (char === ' ' && isCursor ? ' ' : char) + '</span>';
                        } else {
                            html += char;
                        }
                    }
                    if (y < this.rows - 1) {
                        html += '\n';
                    }
                }

                this.container.innerHTML = html;
            }

            resize(cols, rows) {
                // TODO: Implement terminal resizing
                this.cols = cols;
                this.rows = rows;
            }
        }

        // Initialize terminal
        const terminalScreen = document.getElementById('terminal-screen');
        const statusEl = document.getElementById('status');
        const loadingEl = document.getElementById('loading');
        const hiddenInput = document.getElementById('hidden-input');

        const terminal = new VT100Terminal(terminalScreen);

        // Command history management
        const commandHistory = {
            history: [],
            maxSize: 1000,
            currentIndex: -1,
            currentLine: '',
            inputBuffer: '',

            // Add command to history
            addCommand(command) {
                if (command.trim().length > 0) {
                    // Don't add duplicate consecutive commands
                    if (this.history.length === 0 || this.history[this.history.length - 1] !== command) {
                        this.history.push(command);
                        // Limit history size
                        if (this.history.length > this.maxSize) {
                            this.history.shift();
                        }
                    }
                }
                this.currentIndex = this.history.length;
                this.currentLine = '';
            },

            // Navigate to previous command
            getPrevious() {
                if (this.currentIndex === this.history.length) {
                    // Save current line before navigating history
                    this.currentLine = this.inputBuffer;
                }

                if (this.currentIndex > 0) {
                    this.currentIndex--;
                    return this.history[this.currentIndex];
                }
                return null;
            },

            // Navigate to next command
            getNext() {
                if (this.currentIndex < this.history.length - 1) {
                    this.currentIndex++;
                    return this.history[this.currentIndex];
                } else if (this.currentIndex === this.history.length - 1) {
                    this.currentIndex = this.history.length;
                    return this.currentLine; // Restore the line being typed
                }
                return null;
            },

            // Reset to end of history
            reset() {
                this.currentIndex = this.history.length;
                this.currentLine = '';
                this.inputBuffer = '';
            },

            // Update input buffer
            updateBuffer(buffer) {
                this.inputBuffer = buffer;
            }
        };

        // Update status
        function setStatus(status, text) {
            statusEl.className = status;
            statusEl.textContent = text;
        }

        // Socket.IO connection
        const socket = io({
            transports: ['websocket', 'polling'],
            upgrade: true
        });

        // Connection events
        socket.on('connect', () => {
            console.log('Connected to server');
            setStatus('connected', '● Connected');
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            setStatus('disconnected', '○ Disconnected');
            terminal.write('\r\n\r\n=== Connection lost. Please refresh the page. ===\r\n');
        });

        socket.on('connected', (data) => {
            console.log('Server response:', data.data);
        });

        // Output handling
        let firstOutput = true;
        socket.on('output', (data) => {
            terminal.write(data.data);

            // Hide loading screen on first output
            if (firstOutput) {
                firstOutput = false;
                setTimeout(() => {
                    loadingEl.classList.add('hidden');
                    terminalScreen.focus();
                }, 100);
            }
        });

        // Helper function to clear current line and send new text
        function replaceCurrentLine(newText) {
            // Clear current line by sending backspaces
            for (let i = 0; i < commandHistory.inputBuffer.length; i++) {
                socket.emit('input', { data: '\x7f' });
            }

            // Send new text
            for (let i = 0; i < newText.length; i++) {
                socket.emit('input', { data: newText[i] });
            }

            // Update buffer
            commandHistory.updateBuffer(newText);
        }

        // Keyboard input handling
        terminalScreen.addEventListener('keydown', (e) => {
            let data = null;
            let handleHistoryNav = false;

            // Prevent default for most keys
            e.preventDefault();

            if (e.key === 'Enter') {
                data = '\r';
                // Save command to history
                commandHistory.addCommand(commandHistory.inputBuffer);
                commandHistory.reset();
            } else if (e.key === 'Backspace') {
                data = '\x7f'; // DEL character
                // Remove last character from buffer
                if (commandHistory.inputBuffer.length > 0) {
                    commandHistory.updateBuffer(commandHistory.inputBuffer.slice(0, -1));
                }
            } else if (e.key === 'Tab') {
                data = '\t';
            } else if (e.key === 'Escape') {
                data = '\x1b';
            } else if (e.key === 'ArrowUp') {
                // History navigation - previous command
                handleHistoryNav = true;
                const prevCommand = commandHistory.getPrevious();
                if (prevCommand !== null) {
                    replaceCurrentLine(prevCommand);
                }
            } else if (e.key === 'ArrowDown') {
                // History navigation - next command
                handleHistoryNav = true;
                const nextCommand = commandHistory.getNext();
                if (nextCommand !== null) {
                    replaceCurrentLine(nextCommand);
                }
            } else if (e.key === 'ArrowRight') {
                data = '\x1b[C';
            } else if (e.key === 'ArrowLeft') {
                data = '\x1b[D';
            } else if (e.key === 'Home') {
                data = '\x1b[H';
            } else if (e.key === 'End') {
                data = '\x1b[F';
            } else if (e.key === 'Delete') {
                data = '\x1b[3~';
            } else if (e.key === 'Insert') {
                data = '\x1b[2~';
            } else if (e.key === 'PageUp') {
                data = '\x1b[5~';
            } else if (e.key === 'PageDown') {
                data = '\x1b[6~';
            } else if (e.ctrlKey && e.key === 'c') {
                data = '\x03'; // Ctrl+C
                // Reset input buffer and history position on Ctrl+C
                commandHistory.reset();
            } else if (e.ctrlKey && e.key === 'd') {
                data = '\x04'; // Ctrl+D
            } else if (e.ctrlKey && e.key === 'z') {
                data = '\x1a'; // Ctrl+Z
            } else if (e.ctrlKey && e.key === 'l') {
                data = '\x0c'; // Ctrl+L
            } else if (e.ctrlKey && e.key === 'u') {
                // Ctrl+U: Clear line
                data = '\x15';
                commandHistory.reset();
            } else if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
                data = e.key;
                // Add character to buffer
                commandHistory.updateBuffer(commandHistory.inputBuffer + e.key);
            }

            if (data && !handleHistoryNav) {
                socket.emit('input', { data: data });
            }
        });

        // Focus terminal on click
        document.addEventListener('click', () => {
            terminalScreen.focus();
        });

        // Focus terminal on load
        window.addEventListener('load', () => {
            terminalScreen.focus();
        });

        // Prevent context menu
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        console.log('VT100 Terminal Emulator initialized');
        console.log('80x24 character display');
        console.log('Full ANSI escape sequence support');
    </script>
</body>
</html>
