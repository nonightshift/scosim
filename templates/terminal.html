<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCO Unix System V/386 - VT100 Terminal</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            color: #00ff00;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        #header {
            background-color: #1a1a1a;
            color: #00ff00;
            padding: 10px 20px;
            border-bottom: 2px solid #00ff00;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        #header h1 {
            font-size: 16px;
            font-weight: bold;
        }

        #status {
            font-size: 12px;
        }

        #status.connected {
            color: #00ff00;
        }

        #status.disconnected {
            color: #ff0000;
        }

        #status.connecting {
            color: #ffff00;
        }

        /* Terminal Container */
        #terminal-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: #000;
            padding: 10px;
        }

        /* VT100 Terminal Display */
        #terminal-screen {
            font-family: 'Courier New', Courier, monospace;
            font-size: 16px;
            line-height: 1.2;
            white-space: pre;
            word-break: keep-all;
            overflow-wrap: normal;
            color: #00ff00;
            background-color: #000;
            flex: 1;
            overflow-y: scroll;
            overflow-x: hidden;
            position: relative;
            cursor: default;
            user-select: none;
            min-height: 0;
            box-sizing: border-box;
        }

        /* Custom scrollbar styling for terminal */
        #terminal-screen::-webkit-scrollbar {
            width: 12px;
        }

        #terminal-screen::-webkit-scrollbar-track {
            background: #000;
        }

        #terminal-screen::-webkit-scrollbar-thumb {
            background: #00ff00;
            border: 2px solid #000;
        }

        #terminal-screen::-webkit-scrollbar-thumb:hover {
            background: #00dd00;
        }

        /* Firefox scrollbar styling */
        #terminal-screen {
            scrollbar-width: thin;
            scrollbar-color: #00ff00 #000;
        }

        /* Cursor styles */
        .cursor-block {
            display: inline-block;
            background-color: #00ff00;
            color: #000;
            animation: blink-block 1s infinite;
        }

        .cursor-underline {
            text-decoration: underline;
            text-decoration-color: #00ff00;
            text-decoration-thickness: 2px;
        }

        @keyframes blink-block {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0.3; }
        }

        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #00ff00;
        }

        #loading h2 {
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
        }

        #loading .spinner {
            border: 4px solid #1a1a1a;
            border-top: 4px solid #00ff00;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        #loading p {
            margin-top: 20px;
            font-size: 14px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        /* ANSI color classes */
        .ansi-black { color: #000000; }
        .ansi-red { color: #ff0000; }
        .ansi-green { color: #00ff00; }
        .ansi-yellow { color: #ffff00; }
        .ansi-blue { color: #0000ff; }
        .ansi-magenta { color: #ff00ff; }
        .ansi-cyan { color: #00ffff; }
        .ansi-white { color: #ffffff; }
        .ansi-bright-black { color: #555555; }
        .ansi-bright-red { color: #ff5555; }
        .ansi-bright-green { color: #55ff55; }
        .ansi-bright-yellow { color: #ffff55; }
        .ansi-bright-blue { color: #5555ff; }
        .ansi-bright-magenta { color: #ff55ff; }
        .ansi-bright-cyan { color: #55ffff; }
        .ansi-bright-white { color: #ffffff; }

        .ansi-bg-black { background-color: #000000; }
        .ansi-bg-red { background-color: #ff0000; }
        .ansi-bg-green { background-color: #00ff00; }
        .ansi-bg-yellow { background-color: #ffff00; }
        .ansi-bg-blue { background-color: #0000ff; }
        .ansi-bg-magenta { background-color: #ff00ff; }
        .ansi-bg-cyan { background-color: #00ffff; }
        .ansi-bg-white { background-color: #ffffff; }

        .ansi-bold { font-weight: bold; }
        .ansi-dim { opacity: 0.5; }
        .ansi-underline { text-decoration: underline; }
        .ansi-blink { animation: blink 1s infinite; }
        .ansi-reverse { filter: invert(1); }
        .ansi-hidden { visibility: hidden; }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        /* Hidden input for mobile keyboard support */
        #hidden-input {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
        }

        /* Skull Animation Styles */
        #animation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .flying-char {
            position: absolute;
            font-family: 'Courier New', Courier, monospace;
            font-size: 16px;
            line-height: 1.2;
            color: #00ff00;
            pointer-events: none;
            transition: all 0.05s linear;
            will-change: transform;
        }

        .flying-char.wild {
            animation: wildFly 0.1s infinite;
        }

        @keyframes wildFly {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(2px, -2px) rotate(5deg); }
            50% { transform: translate(-2px, 2px) rotate(-5deg); }
            75% { transform: translate(2px, 2px) rotate(3deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }

        .flying-char.forming {
            transition: all 2s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        .flying-char.returning {
            transition: all 2s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        /* Intro Animation Styles */
        #intro-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }

        #intro-animation.fade-out {
            opacity: 0;
        }

        /* Digital Clock Display */
        .digital-clock {
            font-family: 'Courier New', Courier, monospace;
            color: #00ff00;
            text-align: center;
            text-shadow: 0 0 20px #00ff00, 0 0 40px #00ff00;
            user-select: none;
        }

        .clock-time {
            font-size: 12vw;
            font-weight: bold;
            letter-spacing: 0.1em;
            line-height: 1;
            margin: 0;
            padding: 0;
        }

        .clock-date {
            font-size: 3.6vw;
            margin-top: 2vh;
            letter-spacing: 0.15em;
            opacity: 0.9;
        }

        /* Blur effect for time travel */
        .time-blur {
            filter: blur(3px);
            transition: filter 0.3s;
        }

        /* Warp Tunnel Effect */
        #warp-tunnel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 1s ease-in-out;
            overflow: hidden;
            perspective: 1000px;
        }

        #warp-tunnel.active {
            opacity: 1;
        }

        .warp-line {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 200%;
            height: 3px;
            transform-origin: 0 50%;
            will-change: transform, opacity;
            pointer-events: none;
        }

        .warp-line::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                rgba(0, 255, 0, 0) 0%,
                rgba(0, 255, 0, 0.8) 30%,
                rgba(0, 255, 0, 1) 50%,
                rgba(0, 255, 0, 0.8) 70%,
                rgba(0, 255, 0, 0) 100%
            );
            box-shadow: 0 0 10px rgba(0, 255, 0, 0.8),
                        0 0 20px rgba(0, 255, 0, 0.4);
        }

        /* Dynamic warp speed classes */
        #warp-tunnel.speed-slow .warp-line {
            animation: warpMoveSlow 2s ease-out infinite;
        }

        #warp-tunnel.speed-medium .warp-line {
            animation: warpMoveMedium 0.8s ease-in-out infinite;
        }

        #warp-tunnel.speed-fast .warp-line {
            animation: warpMoveFast 0.3s linear infinite;
        }

        #warp-tunnel.speed-stopping .warp-line {
            animation: warpMoveStopping 3s ease-out infinite;
        }

        @keyframes warpMoveSlow {
            0% {
                transform: translateX(0) scaleX(0);
                opacity: 0;
            }
            20% {
                opacity: 0.6;
            }
            100% {
                transform: translateX(80vw) scaleX(1.5);
                opacity: 0;
            }
        }

        @keyframes warpMoveMedium {
            0% {
                transform: translateX(0) scaleX(0);
                opacity: 0;
            }
            30% {
                opacity: 0.8;
            }
            100% {
                transform: translateX(100vw) scaleX(2);
                opacity: 0;
            }
        }

        @keyframes warpMoveFast {
            0% {
                transform: translateX(0) scaleX(0);
                opacity: 0;
            }
            40% {
                opacity: 1;
            }
            100% {
                transform: translateX(120vw) scaleX(3);
                opacity: 0;
            }
        }

        @keyframes warpMoveStopping {
            0% {
                transform: translateX(0) scaleX(0);
                opacity: 0;
            }
            15% {
                opacity: 0.4;
            }
            100% {
                transform: translateX(60vw) scaleX(1);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <!-- Intro Animation -->
    <div id="intro-animation">
        <div id="warp-tunnel"></div>
        <div class="digital-clock" id="digital-clock">
            <div class="clock-time" id="clock-time">00:00:00</div>
            <div class="clock-date" id="clock-date">01.01.2025</div>
        </div>
    </div>
    <!-- Loading Screen (initially hidden) -->
    <div id="loading" class="hidden">
        <h2>SCO UNIX SYSTEM V/386</h2>
        <div class="spinner"></div>
        <p>Initializing VT100 terminal...</p>
    </div>

    <!-- Header (initially hidden) -->
    <div id="header" style="display: none;">
        <h1>SCO Unix System V/386 - VT100 Terminal Emulator</h1>
        <div id="status" class="connecting">● Connecting...</div>
    </div>

    <!-- Terminal (initially hidden) -->
    <div id="terminal-container" style="display: none;">
        <div id="terminal-screen" tabindex="0"></div>
        <input type="text" id="hidden-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
    </div>

    <!-- Animation Overlay -->
    <div id="animation-overlay"></div>

    <!-- Socket.IO -->
    <script src="{{ url_for('static', filename='js/socket.io.min.js') }}"></script>

    <script>
        /**
         * VT100 Terminal Emulator
         * Implements a classic VT100 terminal with ANSI escape sequence support
         */
        class VT100Terminal {
            constructor(containerElement) {
                this.container = containerElement;
                this.cols = 80;
                this.rows = 24;
                this.cursorX = 0;
                this.cursorY = 0;
                this.savedCursorX = 0;
                this.savedCursorY = 0;
                this.scrollTop = 0;
                this.scrollBottom = this.rows - 1;

                // Screen buffer: each cell contains {char, style}
                this.buffer = [];
                for (let i = 0; i < this.rows; i++) {
                    this.buffer[i] = [];
                    for (let j = 0; j < this.cols; j++) {
                        this.buffer[i][j] = { char: ' ', style: this.defaultStyle() };
                    }
                }

                // Current text style
                this.currentStyle = this.defaultStyle();

                // ANSI parser state
                this.parseState = 'normal';
                this.escapeBuffer = '';

                // Cursor visibility and blinking
                this.cursorVisible = true;
                this.cursorBlink = true;

                // Start cursor blink timer
                this.startCursorBlink();

                // Initial render
                this.render();
            }

            defaultStyle() {
                return {
                    fg: 'green',
                    bg: 'black',
                    bold: false,
                    dim: false,
                    underline: false,
                    blink: false,
                    reverse: false,
                    hidden: false
                };
            }

            startCursorBlink() {
                setInterval(() => {
                    this.cursorBlink = !this.cursorBlink;
                    this.render();
                }, 530); // VT100 cursor blinks at ~1.875 Hz
            }

            /**
             * Write data to the terminal
             */
            write(data) {
                for (let i = 0; i < data.length; i++) {
                    const char = data[i];

                    if (this.parseState === 'normal') {
                        this.handleNormalChar(char);
                    } else if (this.parseState === 'escape') {
                        this.handleEscapeChar(char);
                    } else if (this.parseState === 'csi') {
                        this.handleCSIChar(char);
                    }
                }

                this.render();
            }

            handleNormalChar(char) {
                const code = char.charCodeAt(0);

                if (code === 27) { // ESC
                    this.parseState = 'escape';
                    this.escapeBuffer = '';
                } else if (code === 8) { // Backspace
                    if (this.cursorX > 0) {
                        this.cursorX--;
                    }
                } else if (code === 9) { // Tab
                    this.cursorX = Math.min(this.cols - 1, (Math.floor(this.cursorX / 8) + 1) * 8);
                } else if (code === 10) { // Line Feed
                    this.lineFeed();
                } else if (code === 13) { // Carriage Return
                    this.cursorX = 0;
                } else if (code === 7) { // Bell
                    // Beep sound (ignored in web)
                } else if (code >= 32 && code < 127) { // Printable ASCII
                    this.putChar(char);
                    this.cursorX++;
                    if (this.cursorX >= this.cols) {
                        this.cursorX = 0;
                        this.lineFeed();
                    }
                }
            }

            handleEscapeChar(char) {
                if (char === '[') {
                    this.parseState = 'csi';
                    this.escapeBuffer = '';
                } else if (char === 'M') {
                    // Reverse line feed
                    if (this.cursorY > this.scrollTop) {
                        this.cursorY--;
                    } else {
                        this.scrollDown();
                    }
                    this.parseState = 'normal';
                } else if (char === '7') {
                    // Save cursor
                    this.savedCursorX = this.cursorX;
                    this.savedCursorY = this.cursorY;
                    this.parseState = 'normal';
                } else if (char === '8') {
                    // Restore cursor
                    this.cursorX = this.savedCursorX;
                    this.cursorY = this.savedCursorY;
                    this.parseState = 'normal';
                } else if (char === 'c') {
                    // Reset terminal
                    this.reset();
                    this.parseState = 'normal';
                } else {
                    this.parseState = 'normal';
                }
            }

            handleCSIChar(char) {
                const code = char.charCodeAt(0);

                if ((code >= 48 && code <= 57) || char === ';' || char === '?') {
                    // Parameter character
                    this.escapeBuffer += char;
                } else {
                    // Command character
                    this.executeCSI(this.escapeBuffer, char);
                    this.parseState = 'normal';
                }
            }

            executeCSI(params, command) {
                const args = params.split(';').map(x => parseInt(x) || 0);

                switch (command) {
                    case 'A': // Cursor Up
                        this.cursorY = Math.max(this.scrollTop, this.cursorY - (args[0] || 1));
                        break;
                    case 'B': // Cursor Down
                        this.cursorY = Math.min(this.scrollBottom, this.cursorY + (args[0] || 1));
                        break;
                    case 'C': // Cursor Forward
                        this.cursorX = Math.min(this.cols - 1, this.cursorX + (args[0] || 1));
                        break;
                    case 'D': // Cursor Back
                        this.cursorX = Math.max(0, this.cursorX - (args[0] || 1));
                        break;
                    case 'H': // Cursor Position
                    case 'f':
                        this.cursorY = Math.min(this.rows - 1, Math.max(0, (args[0] || 1) - 1));
                        this.cursorX = Math.min(this.cols - 1, Math.max(0, (args[1] || 1) - 1));
                        break;
                    case 'J': // Erase in Display
                        this.eraseDisplay(args[0] || 0);
                        break;
                    case 'K': // Erase in Line
                        this.eraseLine(args[0] || 0);
                        break;
                    case 'm': // Select Graphic Rendition
                        this.setGraphicRendition(args);
                        break;
                    case 'r': // Set Scrolling Region
                        this.scrollTop = Math.max(0, (args[0] || 1) - 1);
                        this.scrollBottom = Math.min(this.rows - 1, (args[1] || this.rows) - 1);
                        break;
                    case 's': // Save cursor position
                        this.savedCursorX = this.cursorX;
                        this.savedCursorY = this.cursorY;
                        break;
                    case 'u': // Restore cursor position
                        this.cursorX = this.savedCursorX;
                        this.cursorY = this.savedCursorY;
                        break;
                    case 'l': // Reset Mode
                        if (params === '?25') {
                            this.cursorVisible = false;
                        }
                        break;
                    case 'h': // Set Mode
                        if (params === '?25') {
                            this.cursorVisible = true;
                        }
                        break;
                }
            }

            setGraphicRendition(args) {
                if (args.length === 0 || args[0] === 0) {
                    this.currentStyle = this.defaultStyle();
                    return;
                }

                for (let i = 0; i < args.length; i++) {
                    const arg = args[i];

                    if (arg === 0) {
                        this.currentStyle = this.defaultStyle();
                    } else if (arg === 1) {
                        this.currentStyle.bold = true;
                    } else if (arg === 2) {
                        this.currentStyle.dim = true;
                    } else if (arg === 4) {
                        this.currentStyle.underline = true;
                    } else if (arg === 5) {
                        this.currentStyle.blink = true;
                    } else if (arg === 7) {
                        this.currentStyle.reverse = true;
                    } else if (arg === 8) {
                        this.currentStyle.hidden = true;
                    } else if (arg === 22) {
                        this.currentStyle.bold = false;
                        this.currentStyle.dim = false;
                    } else if (arg === 24) {
                        this.currentStyle.underline = false;
                    } else if (arg === 25) {
                        this.currentStyle.blink = false;
                    } else if (arg === 27) {
                        this.currentStyle.reverse = false;
                    } else if (arg === 28) {
                        this.currentStyle.hidden = false;
                    } else if (arg >= 30 && arg <= 37) {
                        // Foreground colors
                        const colors = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
                        this.currentStyle.fg = colors[arg - 30];
                    } else if (arg >= 40 && arg <= 47) {
                        // Background colors
                        const colors = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
                        this.currentStyle.bg = colors[arg - 40];
                    } else if (arg >= 90 && arg <= 97) {
                        // Bright foreground colors
                        const colors = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
                        this.currentStyle.fg = 'bright-' + colors[arg - 90];
                    } else if (arg >= 100 && arg <= 107) {
                        // Bright background colors
                        const colors = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
                        this.currentStyle.bg = 'bright-' + colors[arg - 100];
                    }
                }
            }

            eraseDisplay(mode) {
                if (mode === 0) { // Erase from cursor to end
                    this.eraseLine(0);
                    for (let y = this.cursorY + 1; y < this.rows; y++) {
                        for (let x = 0; x < this.cols; x++) {
                            this.buffer[y][x] = { char: ' ', style: this.defaultStyle() };
                        }
                    }
                } else if (mode === 1) { // Erase from start to cursor
                    this.eraseLine(1);
                    for (let y = 0; y < this.cursorY; y++) {
                        for (let x = 0; x < this.cols; x++) {
                            this.buffer[y][x] = { char: ' ', style: this.defaultStyle() };
                        }
                    }
                } else if (mode === 2) { // Erase entire display
                    for (let y = 0; y < this.rows; y++) {
                        for (let x = 0; x < this.cols; x++) {
                            this.buffer[y][x] = { char: ' ', style: this.defaultStyle() };
                        }
                    }
                }
            }

            eraseLine(mode) {
                if (mode === 0) { // Erase from cursor to end of line
                    for (let x = this.cursorX; x < this.cols; x++) {
                        this.buffer[this.cursorY][x] = { char: ' ', style: this.defaultStyle() };
                    }
                } else if (mode === 1) { // Erase from start of line to cursor
                    for (let x = 0; x <= this.cursorX; x++) {
                        this.buffer[this.cursorY][x] = { char: ' ', style: this.defaultStyle() };
                    }
                } else if (mode === 2) { // Erase entire line
                    for (let x = 0; x < this.cols; x++) {
                        this.buffer[this.cursorY][x] = { char: ' ', style: this.defaultStyle() };
                    }
                }
            }

            putChar(char) {
                this.buffer[this.cursorY][this.cursorX] = {
                    char: char,
                    style: Object.assign({}, this.currentStyle)
                };
            }

            lineFeed() {
                if (this.cursorY >= this.scrollBottom) {
                    this.scrollUp();
                } else {
                    this.cursorY++;
                }
            }

            scrollUp() {
                // Move lines up
                for (let y = this.scrollTop; y < this.scrollBottom; y++) {
                    this.buffer[y] = this.buffer[y + 1];
                }
                // Clear bottom line
                this.buffer[this.scrollBottom] = [];
                for (let x = 0; x < this.cols; x++) {
                    this.buffer[this.scrollBottom][x] = { char: ' ', style: this.defaultStyle() };
                }
            }

            scrollDown() {
                // Move lines down
                for (let y = this.scrollBottom; y > this.scrollTop; y--) {
                    this.buffer[y] = this.buffer[y - 1];
                }
                // Clear top line
                this.buffer[this.scrollTop] = [];
                for (let x = 0; x < this.cols; x++) {
                    this.buffer[this.scrollTop][x] = { char: ' ', style: this.defaultStyle() };
                }
            }

            reset() {
                this.cursorX = 0;
                this.cursorY = 0;
                this.scrollTop = 0;
                this.scrollBottom = this.rows - 1;
                this.currentStyle = this.defaultStyle();
                this.eraseDisplay(2);
            }

            /**
             * Render the terminal to the DOM
             */
            render() {
                let html = '';

                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        const cell = this.buffer[y][x];
                        const isCursor = (x === this.cursorX && y === this.cursorY && this.cursorVisible && this.cursorBlink);

                        let char = cell.char;
                        let classes = [];
                        let style = cell.style;

                        // Apply text styles
                        if (style.fg !== 'green') classes.push('ansi-' + style.fg);
                        if (style.bg !== 'black') classes.push('ansi-bg-' + style.bg);
                        if (style.bold) classes.push('ansi-bold');
                        if (style.dim) classes.push('ansi-dim');
                        if (style.underline) classes.push('ansi-underline');
                        if (style.blink) classes.push('ansi-blink');
                        if (style.reverse) classes.push('ansi-reverse');
                        if (style.hidden) classes.push('ansi-hidden');

                        if (isCursor) {
                            classes.push('cursor-block');
                        }

                        if (classes.length > 0) {
                            html += '<span class="' + classes.join(' ') + '">' + (char === ' ' && isCursor ? ' ' : char) + '</span>';
                        } else {
                            html += char;
                        }
                    }
                    if (y < this.rows - 1) {
                        html += '\n';
                    }
                }

                this.container.innerHTML = html;
            }

            resize(cols, rows) {
                // Don't resize if dimensions are the same
                if (this.cols === cols && this.rows === rows) {
                    return;
                }

                // Create new buffer with new dimensions
                const newBuffer = [];
                for (let i = 0; i < rows; i++) {
                    newBuffer[i] = [];
                    for (let j = 0; j < cols; j++) {
                        // Copy existing content if within bounds, otherwise use default
                        if (i < this.buffer.length && j < this.buffer[i].length) {
                            newBuffer[i][j] = this.buffer[i][j];
                        } else {
                            newBuffer[i][j] = { char: ' ', style: this.defaultStyle() };
                        }
                    }
                }

                // Update dimensions and buffer
                this.cols = cols;
                this.rows = rows;
                this.buffer = newBuffer;

                // Adjust cursor position if needed
                if (this.cursorX >= cols) this.cursorX = cols - 1;
                if (this.cursorY >= rows) this.cursorY = rows - 1;

                // Adjust scroll region
                this.scrollTop = 0;
                this.scrollBottom = rows - 1;

                // Re-render with new dimensions
                this.render();
            }

            /**
             * Calculate optimal terminal dimensions based on container size
             */
            calculateOptimalDimensions() {
                // Get container dimensions - use offsetWidth/Height for more accurate measurements
                const containerWidth = this.container.offsetWidth || this.container.clientWidth;
                const containerHeight = this.container.offsetHeight || this.container.clientHeight;

                console.log(`Container size: ${containerWidth}px x ${containerHeight}px`);

                // Create a temporary span to measure character dimensions at current zoom level
                const tempSpan = document.createElement('span');
                tempSpan.style.fontFamily = 'Courier New, Courier, monospace';
                tempSpan.style.fontSize = '16px';
                tempSpan.style.lineHeight = '1.2';
                tempSpan.style.visibility = 'hidden';
                tempSpan.style.position = 'absolute';
                tempSpan.style.whiteSpace = 'pre';
                tempSpan.textContent = 'X';

                // Append to the terminal container to ensure same zoom context
                this.container.appendChild(tempSpan);

                const charMetrics = tempSpan.getBoundingClientRect();
                const charWidth = charMetrics.width;
                const charHeight = charMetrics.height;

                this.container.removeChild(tempSpan);

                console.log(`Character metrics at current zoom: ${charWidth}px width, ${charHeight}px height`);

                // Calculate actual scrollbar width dynamically
                const scrollbarWidth = this.container.offsetWidth - this.container.clientWidth;
                console.log(`Detected scrollbar width: ${scrollbarWidth}px`);

                // Calculate how many characters fit
                const safetyMargin = 8; // Increased margin to prevent wrapping
                const availableWidth = containerWidth - scrollbarWidth - safetyMargin;
                const availableHeight = containerHeight - safetyMargin;

                const cols = Math.floor(availableWidth / charWidth);
                const rows = Math.floor(availableHeight / charHeight);

                console.log(`Calculated dimensions: ${cols} cols x ${rows} rows`);

                // Ensure minimum dimensions
                const minCols = 40;
                const minRows = 12;

                return {
                    cols: Math.max(minCols, cols),
                    rows: Math.max(minRows, rows),
                    charWidth: charWidth,
                    charHeight: charHeight
                };
            }

            /**
             * Fit terminal to current container size
             */
            fitToContainer() {
                // Check if container is visible
                if (this.container.offsetWidth === 0 || this.container.offsetHeight === 0) {
                    console.warn('Terminal container not visible, skipping resize');
                    return;
                }

                const { cols, rows, charWidth, charHeight } = this.calculateOptimalDimensions();
                console.log(`Resizing terminal to ${cols}x${rows} (container fit)`);

                // Resize the terminal buffer and content
                this.resize(cols, rows);

                // Set explicit width on terminal screen to prevent text wrapping
                // Width = cols * charWidth (using the actual measured character width at current zoom)
                const terminalWidth = cols * charWidth;

                // Remove flex grow to allow fixed width
                this.container.style.flex = '0 0 auto';
                this.container.style.width = `${terminalWidth}px`;
                this.container.style.maxWidth = `${terminalWidth}px`;
                this.container.style.minWidth = `${terminalWidth}px`;

                console.log(`Setting terminal width to ${terminalWidth}px (${cols} cols × ${charWidth}px)`);

                // Force a re-render to apply the new dimensions
                this.render();

                // Verify the actual rendered width
                setTimeout(() => {
                    const actualWidth = this.container.clientWidth;
                    console.log(`Actual terminal width after resize: ${actualWidth}px`);
                    console.log(`Expected ${cols} cols × ${charWidth}px = ${terminalWidth}px`);
                    if (Math.abs(actualWidth - terminalWidth) > 10) {
                        console.warn(`Width mismatch! Expected ${terminalWidth}px but got ${actualWidth}px. Retrying...`);
                        // Retry once if there's a significant mismatch
                        this.fitToContainer();
                    }
                }, 100);
            }
        }

        /**
         * Intro Animation System
         * Time travel animation from present to 1995
         */
        class IntroAnimation {
            constructor() {
                this.container = document.getElementById('intro-animation');
                this.clockElement = document.getElementById('digital-clock');
                this.timeElement = document.getElementById('clock-time');
                this.dateElement = document.getElementById('clock-date');
                this.warpTunnel = document.getElementById('warp-tunnel');

                // Target time in the past
                this.targetDate = new Date(1995, 11, 11, 1, 45, 0); // Dec 11, 1995, 01:45:00

                // Current display time
                this.currentDisplayTime = new Date();

                // Animation state
                this.isRunning = false;
                this.isForwardTraveling = false;
                this.animationPhase = 'present'; // present, slowing, stopped, rewinding, approaching, past, transition
                this.updateInterval = null;
                this.keyHandler = null;
                this.skipRequested = false;

                // Setup global TAB handler to skip animation
                this.setupSkipHandler();
            }

            /**
             * Setup TAB key handler to skip animation
             */
            setupSkipHandler() {
                this.skipHandler = (e) => {
                    if (e.key === 'Tab' && this.isRunning && !this.skipRequested) {
                        e.preventDefault(); // Prevent default tab behavior
                        console.log('TAB pressed - skipping intro animation');
                        this.skip();
                    }
                };
                document.addEventListener('keydown', this.skipHandler, true);
            }

            /**
             * Skip the entire intro animation and jump directly to terminal
             */
            skip() {
                if (!this.isRunning || this.skipRequested) return;

                this.skipRequested = true;
                console.log('Skipping intro animation...');

                // Clear any running intervals or timers
                if (this.updateInterval) {
                    clearInterval(this.updateInterval);
                    this.updateInterval = null;
                }

                // Remove any active key handlers
                if (this.keyHandler) {
                    document.removeEventListener('keydown', this.keyHandler, true);
                    this.keyHandler = null;
                }

                // Deactivate warp tunnel effects
                if (this.warpTunnel) {
                    this.warpTunnel.classList.remove('active', 'speed-slow', 'speed-medium', 'speed-fast', 'speed-stopping');
                }

                // Remove time blur effects
                if (this.timeElement) {
                    this.timeElement.classList.remove('time-blur');
                }
                if (this.dateElement) {
                    this.dateElement.classList.remove('time-blur');
                }

                // Immediately hide intro animation (no transition)
                this.container.style.transition = 'none';
                this.container.style.opacity = '0';
                this.container.style.display = 'none';

                this.isRunning = false;
            }

            /**
             * Forward time travel animation back to present
             * Called when CTRL-C is pressed
             */
            async forwardTimeTravel() {
                if (this.isForwardTraveling) {
                    console.log('Forward time travel already in progress');
                    return;
                }

                this.isForwardTraveling = true;
                console.log('CTRL-C pressed - Starting time travel back to present');

                try {
                    // Clear any running intervals
                    if (this.updateInterval) {
                        clearInterval(this.updateInterval);
                        this.updateInterval = null;
                    }

                    // Remove any active key handlers
                    if (this.keyHandler) {
                        document.removeEventListener('keydown', this.keyHandler, true);
                        this.keyHandler = null;
                    }

                    // Show the clock container if hidden
                    this.container.style.display = 'flex';
                    this.container.style.transition = 'opacity 0.3s ease';
                    this.container.style.opacity = '1';

                    // Phase 1: Slow down (2 seconds)
                    await this.forwardSlowDownPhase();

                    // Phase 2: Stop (1.5 seconds)
                    await this.forwardStopPhase();

                    // Phase 3: Fast forward to present (8 seconds)
                    await this.fastForwardPhase();

                    // Phase 4: Approach present (2 seconds)
                    await this.approachPresentPhase();

                    // Phase 5: Arrive at present and continue normally
                    await this.arriveAtPresentPhase();

                    console.log('Time travel to present completed');
                } finally {
                    this.isForwardTraveling = false;
                }
            }

            /**
             * Phase 1: Slow down before forward travel
             */
            async forwardSlowDownPhase() {
                console.log('Forward Phase: Slowing down');
                this.animationPhase = 'forward_slowing';

                // Activate warp tunnel with slow speed
                this.createWarpTunnel();
                this.setWarpSpeed('slow');
                this.warpTunnel.classList.add('active');

                const duration = 2000; // 2 seconds
                const startTime = Date.now();
                const startDisplayTime = this.currentDisplayTime.getTime();

                return new Promise((resolve) => {
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);

                        // Progressive deceleration (ease-out cubic)
                        const easedProgress = 1 - Math.pow(1 - progress, 3);
                        const speed = 1 - easedProgress;

                        // Update time (slowing down)
                        const timeOffset = speed * elapsed;
                        this.currentDisplayTime = new Date(startDisplayTime + timeOffset);
                        this.updateDisplay();

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    };
                    animate();
                });
            }

            /**
             * Phase 2: Stop before forward travel
             */
            async forwardStopPhase() {
                console.log('Forward Phase: Stopped');
                this.animationPhase = 'forward_stopped';

                // Keep warp effect but at stopping speed
                this.setWarpSpeed('stopping');

                await this.delay(1500);
            }

            /**
             * Phase 3: Fast forward to present (8 seconds)
             */
            async fastForwardPhase() {
                console.log('Forward Phase: Fast forwarding to present');
                this.animationPhase = 'fast_forwarding';

                // Add blur effect for ultra-fast forward
                this.timeElement.classList.add('time-blur');
                this.dateElement.classList.add('time-blur');

                const duration = 8000; // 8 seconds
                const startTime = Date.now();
                const startDisplayTime = this.currentDisplayTime.getTime();
                const presentTime = new Date();
                const targetTime = presentTime.getTime() - (2 * 1000); // Stop 2 seconds before present
                const totalTimeDiff = targetTime - startDisplayTime;

                return new Promise((resolve) => {
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);

                        // Progressive acceleration and deceleration (ease-in-out)
                        let easedProgress;
                        if (progress < 0.3) {
                            // Ease in (accelerate)
                            const t = progress / 0.3;
                            easedProgress = Math.pow(t, 2) * 0.3;
                            this.setWarpSpeed('medium');
                        } else if (progress < 0.7) {
                            // Linear middle section - maximum speed
                            const t = (progress - 0.3) / 0.4;
                            easedProgress = 0.3 + (t * 0.4);
                            this.setWarpSpeed('fast');
                        } else {
                            // Ease out (decelerate)
                            const t = (progress - 0.7) / 0.3;
                            easedProgress = 0.7 + (1 - Math.pow(1 - t, 2)) * 0.3;
                            this.setWarpSpeed('medium');
                        }

                        // Update time (going forwards)
                        const currentTime = startDisplayTime + (totalTimeDiff * easedProgress);
                        this.currentDisplayTime = new Date(currentTime);
                        this.updateDisplay();

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            // Remove blur effect but keep warp tunnel
                            this.timeElement.classList.remove('time-blur');
                            this.dateElement.classList.remove('time-blur');
                            resolve();
                        }
                    };
                    animate();
                });
            }

            /**
             * Phase 4: Approach present slowly
             */
            async approachPresentPhase() {
                console.log('Forward Phase: Approaching present');
                this.animationPhase = 'approaching_present';

                // Slow down warp tunnel
                this.setWarpSpeed('slow');

                const duration = 2000; // 2 seconds
                const startTime = Date.now();
                const startDisplayTime = this.currentDisplayTime.getTime();

                return new Promise((resolve) => {
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);

                        // Smooth deceleration
                        const easedProgress = 1 - Math.pow(1 - progress, 3);

                        // Calculate target as current real time
                        const targetTime = new Date().getTime();
                        const timeDiff = targetTime - startDisplayTime;

                        // Update time
                        const currentTime = startDisplayTime + (timeDiff * easedProgress);
                        this.currentDisplayTime = new Date(currentTime);
                        this.updateDisplay();

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            // Ensure we're at present
                            this.currentDisplayTime = new Date();
                            this.updateDisplay();
                            resolve();
                        }
                    };
                    animate();
                });
            }

            /**
             * Phase 5: Arrive at present and continue normally
             */
            async arriveAtPresentPhase() {
                console.log('Forward Phase: Arrived at present');
                this.animationPhase = 'present';

                // Very slow warp effect
                this.setWarpSpeed('stopping');

                await this.delay(1000);

                // Fade out warp tunnel
                this.warpTunnel.classList.remove('active');

                await this.delay(500);

                // Start normal time progression
                this.updateInterval = setInterval(() => {
                    this.currentDisplayTime = new Date();
                    this.updateDisplay();
                }, 1000);

                console.log('Clock now running normally at present time');
            }

            /**
             * Cleanup skip handler
             */
            cleanup() {
                if (this.skipHandler) {
                    document.removeEventListener('keydown', this.skipHandler, true);
                    this.skipHandler = null;
                }
            }

            /**
             * Format time as HH:MM:SS
             */
            formatTime(date) {
                const hours = String(date.getHours()).padStart(2, '0');
                const minutes = String(date.getMinutes()).padStart(2, '0');
                const seconds = String(date.getSeconds()).padStart(2, '0');
                return `${hours}:${minutes}:${seconds}`;
            }

            /**
             * Format date as DD.MM.YYYY
             */
            formatDate(date) {
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = date.getFullYear();
                return `${day}.${month}.${year}`;
            }

            /**
             * Update clock display
             */
            updateDisplay() {
                this.timeElement.textContent = this.formatTime(this.currentDisplayTime);
                this.dateElement.textContent = this.formatDate(this.currentDisplayTime);
            }

            /**
             * Start the intro animation
             */
            async start() {
                if (this.isRunning) return;

                this.isRunning = true;
                console.log('Starting intro animation...');

                try {
                    // Phase 1: Show current time (present)
                    await this.presentPhase();
                    if (this.skipRequested) return;

                    // Wait for user input
                    await this.waitForKeyPress();
                    if (this.skipRequested) return;

                    // Phase 2: Slow down (5 seconds)
                    await this.slowDownPhase();
                    if (this.skipRequested) return;

                    // Phase 3: Stop (3 seconds)
                    await this.stopPhase();
                    if (this.skipRequested) return;

                    // Phase 4: Rewind fast (20 seconds)
                    await this.rewindPhase();
                    if (this.skipRequested) return;

                    // Phase 5: Approach target slowly (5 seconds)
                    await this.approachPhase();
                    if (this.skipRequested) return;

                    // Phase 6: Stop at target (3 seconds)
                    await this.stopAtTargetPhase();
                    if (this.skipRequested) return;

                    // Phase 7: Run clock normally in the past
                    await this.pastPhase();
                    if (this.skipRequested) return;

                    // Wait for user input to transform to terminal
                    await this.waitForKeyPressToTerminal();
                    if (this.skipRequested) return;

                    // Phase 8: Transform to terminal
                    await this.transformToTerminal();

                    this.isRunning = false;
                    console.log('Intro animation completed');
                } finally {
                    // Ensure cleanup happens even if skipped
                    if (this.skipRequested) {
                        console.log('Intro animation was skipped');
                    }
                    this.cleanup();
                }
            }

            /**
             * Phase 1: Present - Show current time
             */
            async presentPhase() {
                console.log('Phase: Present');
                this.animationPhase = 'present';

                // Update clock every second
                this.updateInterval = setInterval(() => {
                    this.currentDisplayTime = new Date();
                    this.updateDisplay();
                }, 1000);

                // Initial display
                this.currentDisplayTime = new Date();
                this.updateDisplay();
            }

            /**
             * Wait for key press
             */
            waitForKeyPress() {
                return new Promise((resolve) => {
                    this.keyHandler = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        document.removeEventListener('keydown', this.keyHandler, true);
                        this.keyHandler = null;
                        resolve();
                    };
                    document.addEventListener('keydown', this.keyHandler, true);
                });
            }

            /**
             * Phase 2: Slow down (3 seconds)
             */
            async slowDownPhase() {
                console.log('Phase: Slowing down');
                this.animationPhase = 'slowing';

                clearInterval(this.updateInterval);

                // Activate warp tunnel with slow speed
                this.createWarpTunnel();
                this.setWarpSpeed('slow');
                this.warpTunnel.classList.add('active');

                const duration = 3000; // 3 seconds
                const startTime = Date.now();
                const startDisplayTime = this.currentDisplayTime.getTime();

                return new Promise((resolve) => {
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);

                        // Progressive deceleration (ease-out cubic)
                        const easedProgress = 1 - Math.pow(1 - progress, 3);
                        const speed = 1 - easedProgress;

                        // Update time
                        const timeOffset = speed * elapsed;
                        this.currentDisplayTime = new Date(startDisplayTime + timeOffset);
                        this.updateDisplay();

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            resolve();
                        }
                    };
                    animate();
                });
            }

            /**
             * Phase 3: Stop (2 seconds)
             */
            async stopPhase() {
                console.log('Phase: Stopped');
                this.animationPhase = 'stopped';

                // Keep warp effect but at stopping speed
                this.setWarpSpeed('stopping');

                await this.delay(2000);
            }

            /**
             * Phase 4: Rewind fast (10 seconds) with dynamic warp tunnel effect
             */
            async rewindPhase() {
                console.log('Phase: Rewinding');
                this.animationPhase = 'rewinding';

                // Warp tunnel is already active from previous phase
                // Add blur effect for ultra-fast rewind
                this.timeElement.classList.add('time-blur');
                this.dateElement.classList.add('time-blur');

                const duration = 10000; // 10 seconds
                const startTime = Date.now();
                const startDisplayTime = this.currentDisplayTime.getTime();
                const targetTime = this.targetDate.getTime() + (3 * 1000); // Stop 3 seconds before target
                const totalTimeDiff = targetTime - startDisplayTime;

                return new Promise((resolve) => {
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);

                        // Progressive acceleration and deceleration (ease-in-out)
                        // First 30%: accelerate, middle 40%: constant speed, last 30%: decelerate
                        let easedProgress;
                        if (progress < 0.3) {
                            // Ease in (accelerate)
                            const t = progress / 0.3;
                            easedProgress = Math.pow(t, 2) * 0.3;
                            // Gradually increase warp speed
                            this.setWarpSpeed('medium');
                        } else if (progress < 0.7) {
                            // Linear middle section - maximum speed
                            const t = (progress - 0.3) / 0.4;
                            easedProgress = 0.3 + (t * 0.4);
                            this.setWarpSpeed('fast');
                        } else {
                            // Ease out (decelerate)
                            const t = (progress - 0.7) / 0.3;
                            easedProgress = 0.7 + (1 - Math.pow(1 - t, 2)) * 0.3;
                            // Gradually decrease warp speed
                            this.setWarpSpeed('medium');
                        }

                        // Update time (going backwards)
                        const currentTime = startDisplayTime + (totalTimeDiff * easedProgress);
                        this.currentDisplayTime = new Date(currentTime);
                        this.updateDisplay();

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            // Remove blur effect but keep warp tunnel
                            this.timeElement.classList.remove('time-blur');
                            this.dateElement.classList.remove('time-blur');
                            resolve();
                        }
                    };
                    animate();
                });
            }

            /**
             * Create warp tunnel effect with animated lines
             */
            createWarpTunnel() {
                // Only create if not already created
                if (this.warpTunnel.children.length > 0) return;

                // Create 40 lines at different angles for better coverage
                for (let i = 0; i < 40; i++) {
                    const line = document.createElement('div');
                    line.className = 'warp-line';

                    // Evenly distributed angles
                    const angle = (i / 40) * 360;
                    const delay = (i / 40) * 0.5;

                    line.style.transform = `rotate(${angle}deg)`;
                    line.style.animationDelay = `${delay}s`;

                    this.warpTunnel.appendChild(line);
                }
            }

            /**
             * Set warp tunnel speed
             */
            setWarpSpeed(speed) {
                // Remove all speed classes
                this.warpTunnel.classList.remove('speed-slow', 'speed-medium', 'speed-fast', 'speed-stopping');

                // Add new speed class
                if (speed) {
                    this.warpTunnel.classList.add(`speed-${speed}`);
                }
            }

            /**
             * Phase 5: Approach target slowly (3 seconds)
             */
            async approachPhase() {
                console.log('Phase: Approaching target');
                this.animationPhase = 'approaching';

                // Slow down warp tunnel
                this.setWarpSpeed('slow');

                const duration = 3000; // 3 seconds
                const startTime = Date.now();
                const startDisplayTime = this.currentDisplayTime.getTime();
                const targetTime = this.targetDate.getTime();
                const timeDiff = targetTime - startDisplayTime;

                return new Promise((resolve) => {
                    const animate = () => {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);

                        // Smooth deceleration
                        const easedProgress = 1 - Math.pow(1 - progress, 3);

                        // Update time
                        const currentTime = startDisplayTime + (timeDiff * easedProgress);
                        this.currentDisplayTime = new Date(currentTime);
                        this.updateDisplay();

                        if (progress < 1) {
                            requestAnimationFrame(animate);
                        } else {
                            // Ensure we're exactly at target
                            this.currentDisplayTime = new Date(this.targetDate);
                            this.updateDisplay();
                            resolve();
                        }
                    };
                    animate();
                });
            }

            /**
             * Phase 6: Stop at target (2 seconds)
             */
            async stopAtTargetPhase() {
                console.log('Phase: Stopped at target');
                this.animationPhase = 'stopped_at_target';

                // Very slow warp effect
                this.setWarpSpeed('stopping');

                await this.delay(1000);

                // Fade out warp tunnel
                this.warpTunnel.classList.remove('active');

                await this.delay(1000);
            }

            /**
             * Phase 7: Run clock normally in the past
             */
            async pastPhase() {
                console.log('Phase: Past');
                this.animationPhase = 'past';

                // Update clock every second from 1995
                this.updateInterval = setInterval(() => {
                    this.currentDisplayTime = new Date(this.currentDisplayTime.getTime() + 1000);
                    this.updateDisplay();
                }, 1000);
            }

            /**
             * Wait for key press to transform to terminal
             */
            waitForKeyPressToTerminal() {
                return new Promise((resolve) => {
                    this.keyHandler = (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        e.stopImmediatePropagation();
                        document.removeEventListener('keydown', this.keyHandler, true);
                        this.keyHandler = null;
                        clearInterval(this.updateInterval);
                        resolve();
                    };
                    document.addEventListener('keydown', this.keyHandler, true);
                });
            }

            /**
             * Phase 8: Morph clock into terminal with smooth fade
             */
            async transformToTerminal() {
                console.log('Phase: Morphing to terminal');
                this.animationPhase = 'transition';

                // Step 1: Start shrinking and moving (1.5 seconds)
                this.clockElement.style.transition = 'all 1.5s cubic-bezier(0.25, 0.1, 0.25, 1)';
                this.clockElement.style.transform = 'translate(-35vw, -35vh) scale(0.4)';
                this.clockElement.style.opacity = '0.8';
                await this.delay(800);

                // Step 2: Continue shrinking and fade (1 second)
                this.clockElement.style.transition = 'all 1s cubic-bezier(0.25, 0.1, 0.25, 1)';
                this.clockElement.style.transform = 'translate(-42vw, -40vh) scale(0.2)';
                this.clockElement.style.opacity = '0.3';
                await this.delay(700);

                // Step 3: Final fade out (0.8 seconds)
                this.clockElement.style.transition = 'opacity 0.8s ease-out';
                this.clockElement.style.opacity = '0';

                // Step 4: Fade out intro container simultaneously
                this.container.style.transition = 'opacity 0.8s ease-out';
                this.container.style.opacity = '0';
                await this.delay(800);

                // Step 5: Hide intro animation
                this.container.style.display = 'none';

                // Small delay to prevent keypress from leaking to terminal
                await this.delay(150);
            }

            /**
             * Delay helper
             */
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        /**
         * Skull Animation System
         * Creates a spectacular animation where terminal characters fly around
         * and form a skull in the center of the screen
         */
        class SkullAnimation {
            constructor(terminal) {
                this.terminal = terminal;
                this.overlay = document.getElementById('animation-overlay');
                this.isRunning = false;
                this.characters = [];
                this.savedBuffer = null;
                this.abortRequested = false;
                this.abortHandler = null;

                // Skull ASCII art (centered)
                this.skullArt = [
                    "                 uuuuuuu                ",
                    "             uu$$$$$$$$$$$uu            ",
                    "          uu$$$$$$$$$$$$$$$$$uu         ",
                    "         u$$$$$$$$$$$$$$$$$$$$$u        ",
                    "        u$$$$$$$$$$$$$$$$$$$$$$$u       ",
                    "       u$$$$$$$$$$$$$$$$$$$$$$$$$u      ",
                    "       u$$$$$$$$$$$$$$$$$$$$$$$$$u      ",
                    "       u$$$$$$\"   \"$$$\"   \"$$$$$$u      ",
                    "       \"$$$$\"      u$u       $$$$\"      ",
                    "        $$$u       u$u       u$$$       ",
                    "        $$$u      u$$$u      u$$$       ",
                    "         \"$$$$uu$$$   $$$uu$$$$\"        ",
                    "          \"$$$$$$$\"   \"$$$$$$$\"          ",
                    "            u$$$$$$$u$$$$$$$u           ",
                    "             u$\"$\"$\"$\"$\"$\"$u             ",
                    "  uuu        $$u$ $ $ $ $u$$       uuu  ",
                    " u$$$$        $$$$$u$u$u$$$       u$$$$ ",
                    "  $$$$$uu      \"$$$$$$$$$\"     uu$$$$$$",
                    "u$$$$$$$$$$$uu    \"\"\"\"\"    uuuu$$$$$$$$$$",
                    "$$$$\"\"\"$$$$$$$$$$uuu   uu$$$$$$$$$\"\"\"$$$\"",
                    " \"\"\"      \"\"$$$$$$$$$$$uu \"\"$\"\"\"         ",
                    "           uuuu \"\"$$$$$$$$$$uuu          ",
                    "  u$$$uuu$$$$$$$$$uu \"\"$$$$$$$$$$$uuu$$$ ",
                    "  $$$$$$$$$$\"\"\"\"           \"\"$$$$$$$$$$$\"",
                    "   \"$$$$$\"                      \"\"$$$$\"\" ",
                    "     $$$\"                         $$$$\"  "
                ];
            }

            /**
             * Start the skull animation
             */
            async start() {
                if (this.isRunning) return;

                this.isRunning = true;
                this.abortRequested = false;
                console.log('Starting skull animation...');

                // Set up abort handler (Backspace to exit)
                this.abortHandler = (e) => {
                    if (e.key === 'Backspace') {
                        console.log('💀 Backspace pressed - aborting skull animation!');
                        this.abortRequested = true;
                        e.preventDefault();
                        e.stopPropagation();
                    }
                };
                document.addEventListener('keydown', this.abortHandler, true);

                // Save current terminal state
                this.saveTerminalState();

                // Phase 1: Extract and create flying characters (2s)
                await this.extractCharacters();

                // Phase 2: Wild flying animation (3s)
                await this.wildFlyingPhase();

                // Phase 3: Form skull (2s)
                await this.formSkullPhase();

                // Phase 4: Hold skull (up to 10s, can be aborted with Backspace)
                await this.holdSkullPhase();

                // Phase 5: Disintegrate (2s)
                await this.disintegratePhase();

                // Phase 6: Return to original positions (2s)
                await this.returnToOriginalPhase();

                // Phase 7: Cleanup and restore
                this.cleanup();

                this.isRunning = false;
                console.log('Skull animation completed');
            }

            /**
             * Save the current terminal buffer
             */
            saveTerminalState() {
                this.savedBuffer = [];
                for (let y = 0; y < this.terminal.rows; y++) {
                    this.savedBuffer[y] = [];
                    for (let x = 0; x < this.terminal.cols; x++) {
                        this.savedBuffer[y][x] = Object.assign({}, this.terminal.buffer[y][x]);
                    }
                }
            }

            /**
             * Extract all characters from terminal and create animated elements
             */
            async extractCharacters() {
                this.characters = [];
                const terminalRect = this.terminal.container.getBoundingClientRect();

                // Create a temporary span to measure exact character dimensions
                const tempSpan = document.createElement('span');
                tempSpan.style.fontFamily = 'Courier New, Courier, monospace';
                tempSpan.style.fontSize = '16px';
                tempSpan.style.lineHeight = '1.2';
                tempSpan.style.position = 'absolute';
                tempSpan.style.visibility = 'hidden';
                tempSpan.textContent = 'X';
                document.body.appendChild(tempSpan);
                const charMetrics = tempSpan.getBoundingClientRect();
                const exactCharWidth = charMetrics.width;
                const exactCharHeight = charMetrics.height;
                document.body.removeChild(tempSpan);

                // Extract each character
                for (let y = 0; y < this.terminal.rows; y++) {
                    for (let x = 0; x < this.terminal.cols; x++) {
                        const cell = this.terminal.buffer[y][x];

                        // Skip empty spaces (but keep some for effect)
                        if (cell.char === ' ' && Math.random() > 0.1) continue;

                        // Create animated character element
                        const charEl = document.createElement('span');
                        charEl.className = 'flying-char';
                        charEl.textContent = cell.char;

                        // Apply styles
                        if (cell.style.fg !== 'green') {
                            charEl.style.color = this.getColorValue(cell.style.fg);
                        }
                        if (cell.style.bold) {
                            charEl.style.fontWeight = 'bold';
                        }

                        // Calculate exact position using measured character dimensions
                        const originalX = terminalRect.left + (x * exactCharWidth);
                        const originalY = terminalRect.top + (y * exactCharHeight);

                        charEl.style.left = originalX + 'px';
                        charEl.style.top = originalY + 'px';

                        // Store character data
                        this.characters.push({
                            element: charEl,
                            originalX: originalX,
                            originalY: originalY,
                            currentX: originalX,
                            currentY: originalY,
                            char: cell.char,
                            terminalX: x,
                            terminalY: y
                        });

                        // Add to overlay
                        this.overlay.appendChild(charEl);
                    }
                }

                // Hide the terminal screen smoothly (characters are now in overlay)
                this.terminal.container.style.transition = 'opacity 0.3s';
                this.terminal.container.style.opacity = '0';

                // Small delay to let DOM update
                await this.delay(300);
            }

            /**
             * Phase 1: Characters fly around wildly
             */
            async wildFlyingPhase() {
                console.log('Wild flying phase...');

                // Make characters fly to random positions
                this.characters.forEach(char => {
                    char.element.classList.add('wild');

                    // Random velocity for each character
                    const vx = (Math.random() - 0.5) * 1000;
                    const vy = (Math.random() - 0.5) * 1000;

                    // Animate over 3 seconds
                    const animate = () => {
                        const newX = char.currentX + vx * 0.016; // 60fps
                        const newY = char.currentY + vy * 0.016;

                        // Wrap around screen edges
                        char.currentX = (newX + window.innerWidth) % window.innerWidth;
                        char.currentY = (newY + window.innerHeight) % window.innerHeight;

                        char.element.style.left = char.currentX + 'px';
                        char.element.style.top = char.currentY + 'px';
                    };

                    // Store animation interval
                    char.flyInterval = setInterval(animate, 16);
                });

                await this.delay(3000);

                // Stop wild flying
                this.characters.forEach(char => {
                    clearInterval(char.flyInterval);
                    char.element.classList.remove('wild');
                });
            }

            /**
             * Phase 2: Form skull in the center
             */
            async formSkullPhase() {
                console.log('Forming skull...');

                // Calculate skull position (centered on screen)
                const skullWidth = 56; // Width of skull art
                const skullHeight = this.skullArt.length;

                const screenCenterX = window.innerWidth / 2;
                const screenCenterY = window.innerHeight / 2;

                const charWidth = 9.6; // Approximate character width in pixels
                const charHeight = 19.2; // Approximate character height in pixels

                const skullStartX = screenCenterX - (skullWidth * charWidth / 2);
                const skullStartY = screenCenterY - (skullHeight * charHeight / 2);

                // Collect all skull characters
                const skullChars = [];
                for (let y = 0; y < this.skullArt.length; y++) {
                    for (let x = 0; x < this.skullArt[y].length; x++) {
                        const char = this.skullArt[y][x];
                        if (char !== ' ') {
                            skullChars.push({
                                char: char,
                                x: skullStartX + (x * charWidth),
                                y: skullStartY + (y * charHeight)
                            });
                        }
                    }
                }

                // Assign each flying character to a skull position
                this.characters.forEach((char, index) => {
                    char.element.classList.add('forming');

                    // Assign to skull position (cycle through if more chars than skull positions)
                    const skullPos = skullChars[index % skullChars.length];

                    char.targetX = skullPos.x;
                    char.targetY = skullPos.y;
                    char.element.textContent = skullPos.char;

                    // Animate to position
                    char.element.style.left = char.targetX + 'px';
                    char.element.style.top = char.targetY + 'px';
                });

                await this.delay(2000);
            }

            /**
             * Phase 3: Hold skull for up to 10 seconds (or until Backspace)
             */
            async holdSkullPhase() {
                console.log('Holding skull... (Press Backspace to skip)');

                // Check every 100ms if abort was requested
                const startTime = Date.now();
                const holdDuration = 10000;

                while (Date.now() - startTime < holdDuration) {
                    if (this.abortRequested) {
                        console.log('Hold phase aborted by user');
                        break;
                    }
                    await this.delay(100);
                }
            }

            /**
             * Phase 4: Disintegrate the skull
             */
            async disintegratePhase() {
                console.log('Disintegrating...');

                // Remove forming class and make characters fly apart again
                this.characters.forEach(char => {
                    char.element.classList.remove('forming');
                    char.element.classList.add('wild');

                    // Random velocity away from center
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;

                    const dx = char.targetX - centerX;
                    const dy = char.targetY - centerY;

                    const angle = Math.atan2(dy, dx);
                    const speed = 500;

                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;

                    // Animate explosion
                    const animate = () => {
                        char.currentX = char.currentX + vx * 0.016;
                        char.currentY = char.currentY + vy * 0.016;

                        char.element.style.left = char.currentX + 'px';
                        char.element.style.top = char.currentY + 'px';
                    };

                    char.currentX = char.targetX;
                    char.currentY = char.targetY;
                    char.explodeInterval = setInterval(animate, 16);
                });

                await this.delay(2000);

                // Stop explosion
                this.characters.forEach(char => {
                    clearInterval(char.explodeInterval);
                    char.element.classList.remove('wild');
                });
            }

            /**
             * Phase 5: Return to original positions
             */
            async returnToOriginalPhase() {
                console.log('Returning to original positions...');

                this.characters.forEach(char => {
                    char.element.classList.add('returning');

                    // Restore original character
                    const originalCell = this.savedBuffer[char.terminalY][char.terminalX];
                    char.element.textContent = originalCell.char;

                    // Animate back to original position
                    char.element.style.left = char.originalX + 'px';
                    char.element.style.top = char.originalY + 'px';
                });

                // Wait for most of the animation
                await this.delay(1500);

                // Start fading in terminal while characters are still visible
                this.terminal.container.style.transition = 'opacity 0.5s';
                this.terminal.container.style.opacity = '1';

                // Continue waiting for animation to complete
                await this.delay(500);

                // Fade out overlay characters
                this.characters.forEach(char => {
                    char.element.style.transition = 'opacity 0.3s';
                    char.element.style.opacity = '0';
                });

                await this.delay(300);
            }

            /**
             * Cleanup and restore terminal
             */
            cleanup() {
                console.log('Cleaning up...');

                // Remove abort handler
                if (this.abortHandler) {
                    document.removeEventListener('keydown', this.abortHandler, true);
                    this.abortHandler = null;
                }

                // Remove all character elements
                this.characters.forEach(char => {
                    char.element.remove();
                });

                this.characters = [];

                // Restore terminal buffer
                if (this.savedBuffer) {
                    for (let y = 0; y < this.terminal.rows; y++) {
                        for (let x = 0; x < this.terminal.cols; x++) {
                            this.terminal.buffer[y][x] = this.savedBuffer[y][x];
                        }
                    }
                    this.terminal.render();
                }

                // Show the terminal screen again with smooth transition
                this.terminal.container.style.transition = 'opacity 0.3s';
                this.terminal.container.style.opacity = '1';

                this.abortRequested = false;
            }

            /**
             * Get CSS color value from ANSI color name
             */
            getColorValue(colorName) {
                const colors = {
                    'black': '#000000',
                    'red': '#ff0000',
                    'green': '#00ff00',
                    'yellow': '#ffff00',
                    'blue': '#0000ff',
                    'magenta': '#ff00ff',
                    'cyan': '#00ffff',
                    'white': '#ffffff',
                    'bright-black': '#555555',
                    'bright-red': '#ff5555',
                    'bright-green': '#55ff55',
                    'bright-yellow': '#ffff55',
                    'bright-blue': '#5555ff',
                    'bright-magenta': '#ff55ff',
                    'bright-cyan': '#55ffff',
                    'bright-white': '#ffffff'
                };
                return colors[colorName] || '#00ff00';
            }

            /**
             * Delay helper
             */
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize terminal
        const terminalScreen = document.getElementById('terminal-screen');
        const statusEl = document.getElementById('status');
        const loadingEl = document.getElementById('loading');
        const hiddenInput = document.getElementById('hidden-input');

        const terminal = new VT100Terminal(terminalScreen);

        // Initialize skull animation
        const skullAnimation = new SkullAnimation(terminal);

        // Easter egg trigger: Triple ESC press within 1 second
        let escPressCount = 0;
        let escPressTimer = null;

        function handleEscapePress() {
            escPressCount++;
            if (escPressCount === 3) {
                console.log('💀 Triple ESC detected - triggering skull animation!');
                if (!skullAnimation.isRunning) {
                    skullAnimation.start();
                }
                escPressCount = 0;
                clearTimeout(escPressTimer);
            } else {
                clearTimeout(escPressTimer);
                escPressTimer = setTimeout(() => {
                    escPressCount = 0;
                }, 1000);
            }
        }

        // Update status
        function setStatus(status, text) {
            statusEl.className = status;
            statusEl.textContent = text;
        }

        // Socket.IO connection
        const socket = io({
            transports: ['websocket', 'polling'],
            upgrade: true
        });

        // Connection events
        socket.on('connect', () => {
            console.log('Connected to server');
            setStatus('connected', '● Connected');
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            setStatus('disconnected', '○ Disconnected');
            terminal.write('\r\n\r\n=== Connection lost. Please refresh the page. ===\r\n');
        });

        socket.on('connected', (data) => {
            console.log('Server response:', data.data);
        });

        // Output handling
        let firstOutput = true;
        socket.on('output', (data) => {
            terminal.write(data.data);

            // Hide loading screen on first output
            if (firstOutput) {
                firstOutput = false;
                setTimeout(() => {
                    loadingEl.classList.add('hidden');
                    terminalScreen.focus();
                }, 100);
            }
        });

        // Declare introAnimation variable for global access
        let introAnimation = null;

        // Keyboard input handling
        terminalScreen.addEventListener('keydown', (e) => {
            // Check for skull animation trigger (multiple options for compatibility)
            // Ctrl+Shift+K or Ctrl+Alt+S (Skull)
            const isSkullShortcut = (
                (e.ctrlKey && e.shiftKey && (e.key === 'K' || e.key === 'k' || e.keyCode === 75)) ||
                (e.ctrlKey && e.altKey && (e.key === 'S' || e.key === 's' || e.keyCode === 83))
            );

            if (isSkullShortcut) {
                e.preventDefault();
                e.stopPropagation();
                if (!skullAnimation.isRunning) {
                    console.log('💀 Skull animation triggered!');
                    skullAnimation.start();
                } else {
                    console.log('⚠️ Animation already running...');
                }
                return;
            }

            let data = null;

            // Prevent default for most keys
            e.preventDefault();

            if (e.key === 'Enter') {
                data = '\r';
            } else if (e.key === 'Backspace') {
                data = '\x7f'; // DEL character
            } else if (e.key === 'Tab') {
                data = '\t';
            } else if (e.key === 'Escape') {
                handleEscapePress(); // Check for triple ESC easter egg
                data = '\x1b';
            } else if (e.key === 'ArrowUp') {
                data = '\x1b[A';
            } else if (e.key === 'ArrowDown') {
                data = '\x1b[B';
            } else if (e.key === 'ArrowRight') {
                data = '\x1b[C';
            } else if (e.key === 'ArrowLeft') {
                data = '\x1b[D';
            } else if (e.key === 'Home') {
                data = '\x1b[H';
            } else if (e.key === 'End') {
                data = '\x1b[F';
            } else if (e.key === 'Delete') {
                data = '\x1b[3~';
            } else if (e.key === 'Insert') {
                data = '\x1b[2~';
            } else if (e.key === 'PageUp') {
                data = '\x1b[5~';
            } else if (e.key === 'PageDown') {
                data = '\x1b[6~';
            } else if (e.ctrlKey && e.key === 'c') {
                // Trigger forward time travel animation back to present
                if (introAnimation && !introAnimation.isForwardTraveling) {
                    introAnimation.forwardTimeTravel();
                }
                data = '\x03'; // Ctrl+C
            } else if (e.ctrlKey && e.key === 'd') {
                data = '\x04'; // Ctrl+D
            } else if (e.ctrlKey && e.key === 'z') {
                data = '\x1a'; // Ctrl+Z
            } else if (e.ctrlKey && e.key === 'l') {
                data = '\x0c'; // Ctrl+L
            } else if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
                data = e.key;
            }

            if (data) {
                socket.emit('input', { data: data });
            }
        });

        // Focus terminal on click
        document.addEventListener('click', () => {
            terminalScreen.focus();
        });

        // Initialize intro animation
        introAnimation = new IntroAnimation();

        // Start intro animation and then show terminal
        window.addEventListener('load', async () => {
            console.log('Starting intro animation...');

            // Run intro animation
            await introAnimation.start();

            // Show header and terminal container
            document.getElementById('header').style.display = 'flex';
            document.getElementById('terminal-container').style.display = 'flex';

            // Wait for layout to complete, then resize terminal to fit viewport
            await new Promise(resolve => requestAnimationFrame(resolve));
            terminal.fitToContainer();

            // Focus terminal (no loading screen needed)
            terminalScreen.focus();

            console.log('Intro animation completed, terminal ready');
        });

        // Handle window resize (including zoom changes)
        let resizeTimeout;
        window.addEventListener('resize', () => {
            // Debounce resize to avoid too many operations
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                const terminalContainer = document.getElementById('terminal-container');
                if (terminalContainer && terminalContainer.style.display !== 'none') {
                    console.log('Window resized, refitting terminal to new dimensions');
                    terminal.fitToContainer();
                }
            }, 100); // Reduced debounce time for faster response
        });

        // Prevent context menu
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        console.log('VT100 Terminal Emulator initialized');
        console.log('Dynamic character display with viewport-adaptive sizing');
        console.log('Full ANSI escape sequence support');
        console.log('⏭️  Press TAB to skip the time-travel animation');
        console.log('💀 Secret Easter Egg: Press Ctrl+Shift+K, Ctrl+Alt+S, or ESC 3 times for a special animation!');
    </script>
</body>
</html>
