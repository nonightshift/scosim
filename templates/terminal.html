<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCO Unix System V/386 - VT100 Terminal</title>

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #000;
            font-family: 'Courier New', Courier, monospace;
            color: #00ff00;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Header */
        #header {
            background-color: #1a1a1a;
            color: #00ff00;
            padding: 10px 20px;
            border-bottom: 2px solid #00ff00;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }

        #header h1 {
            font-size: 16px;
            font-weight: bold;
        }

        #status {
            font-size: 12px;
        }

        #status.connected {
            color: #00ff00;
        }

        #status.disconnected {
            color: #ff0000;
        }

        #status.connecting {
            color: #ffff00;
        }

        /* Terminal Container */
        #terminal-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background-color: #000;
            padding: 10px;
        }

        /* VT100 Terminal Display */
        #terminal-screen {
            font-family: 'Courier New', Courier, monospace;
            font-size: 16px;
            line-height: 1.2;
            white-space: pre;
            color: #00ff00;
            background-color: #000;
            flex: 1;
            overflow: hidden;
            position: relative;
            cursor: default;
            user-select: none;
        }

        /* Cursor styles */
        .cursor-block {
            display: inline-block;
            background-color: #00ff00;
            color: #000;
            animation: blink-block 1s infinite;
        }

        .cursor-underline {
            text-decoration: underline;
            text-decoration-color: #00ff00;
            text-decoration-thickness: 2px;
        }

        @keyframes blink-block {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0.3; }
        }

        /* Loading Screen */
        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: #00ff00;
        }

        #loading h2 {
            font-size: 24px;
            margin-bottom: 20px;
            text-align: center;
        }

        #loading .spinner {
            border: 4px solid #1a1a1a;
            border-top: 4px solid #00ff00;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }

        #loading p {
            margin-top: 20px;
            font-size: 14px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none !important;
        }

        /* ANSI color classes */
        .ansi-black { color: #000000; }
        .ansi-red { color: #ff0000; }
        .ansi-green { color: #00ff00; }
        .ansi-yellow { color: #ffff00; }
        .ansi-blue { color: #0000ff; }
        .ansi-magenta { color: #ff00ff; }
        .ansi-cyan { color: #00ffff; }
        .ansi-white { color: #ffffff; }
        .ansi-bright-black { color: #555555; }
        .ansi-bright-red { color: #ff5555; }
        .ansi-bright-green { color: #55ff55; }
        .ansi-bright-yellow { color: #ffff55; }
        .ansi-bright-blue { color: #5555ff; }
        .ansi-bright-magenta { color: #ff55ff; }
        .ansi-bright-cyan { color: #55ffff; }
        .ansi-bright-white { color: #ffffff; }

        .ansi-bg-black { background-color: #000000; }
        .ansi-bg-red { background-color: #ff0000; }
        .ansi-bg-green { background-color: #00ff00; }
        .ansi-bg-yellow { background-color: #ffff00; }
        .ansi-bg-blue { background-color: #0000ff; }
        .ansi-bg-magenta { background-color: #ff00ff; }
        .ansi-bg-cyan { background-color: #00ffff; }
        .ansi-bg-white { background-color: #ffffff; }

        .ansi-bold { font-weight: bold; }
        .ansi-dim { opacity: 0.5; }
        .ansi-underline { text-decoration: underline; }
        .ansi-blink { animation: blink 1s infinite; }
        .ansi-reverse { filter: invert(1); }
        .ansi-hidden { visibility: hidden; }

        @keyframes blink {
            0%, 49% { opacity: 1; }
            50%, 100% { opacity: 0; }
        }

        /* Hidden input for mobile keyboard support */
        #hidden-input {
            position: absolute;
            left: -9999px;
            width: 1px;
            height: 1px;
            opacity: 0;
        }

        /* Skull Animation Styles */
        #animation-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 9999;
        }

        .flying-char {
            position: absolute;
            font-family: 'Courier New', Courier, monospace;
            font-size: 16px;
            line-height: 1.2;
            color: #00ff00;
            pointer-events: none;
            transition: all 0.05s linear;
            will-change: transform;
        }

        .flying-char.wild {
            animation: wildFly 0.1s infinite;
        }

        @keyframes wildFly {
            0% { transform: translate(0, 0) rotate(0deg); }
            25% { transform: translate(2px, -2px) rotate(5deg); }
            50% { transform: translate(-2px, 2px) rotate(-5deg); }
            75% { transform: translate(2px, 2px) rotate(3deg); }
            100% { transform: translate(0, 0) rotate(0deg); }
        }

        .flying-char.forming {
            transition: all 2s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        .flying-char.returning {
            transition: all 2s cubic-bezier(0.4, 0.0, 0.2, 1);
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <h2>SCO UNIX SYSTEM V/386</h2>
        <div class="spinner"></div>
        <p>Initializing VT100 terminal...</p>
    </div>

    <!-- Header -->
    <div id="header">
        <h1>SCO Unix System V/386 - VT100 Terminal Emulator</h1>
        <div id="status" class="connecting">‚óè Connecting...</div>
    </div>

    <!-- Terminal -->
    <div id="terminal-container">
        <div id="terminal-screen" tabindex="0"></div>
        <input type="text" id="hidden-input" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false">
    </div>

    <!-- Animation Overlay -->
    <div id="animation-overlay"></div>

    <!-- Socket.IO -->
    <script src="{{ url_for('static', filename='js/socket.io.min.js') }}"></script>

    <script>
        /**
         * VT100 Terminal Emulator
         * Implements a classic VT100 terminal with ANSI escape sequence support
         */
        class VT100Terminal {
            constructor(containerElement) {
                this.container = containerElement;
                this.cols = 80;
                this.rows = 24;
                this.cursorX = 0;
                this.cursorY = 0;
                this.savedCursorX = 0;
                this.savedCursorY = 0;
                this.scrollTop = 0;
                this.scrollBottom = this.rows - 1;

                // Screen buffer: each cell contains {char, style}
                this.buffer = [];
                for (let i = 0; i < this.rows; i++) {
                    this.buffer[i] = [];
                    for (let j = 0; j < this.cols; j++) {
                        this.buffer[i][j] = { char: ' ', style: this.defaultStyle() };
                    }
                }

                // Current text style
                this.currentStyle = this.defaultStyle();

                // ANSI parser state
                this.parseState = 'normal';
                this.escapeBuffer = '';

                // Cursor visibility and blinking
                this.cursorVisible = true;
                this.cursorBlink = true;

                // Start cursor blink timer
                this.startCursorBlink();

                // Initial render
                this.render();
            }

            defaultStyle() {
                return {
                    fg: 'green',
                    bg: 'black',
                    bold: false,
                    dim: false,
                    underline: false,
                    blink: false,
                    reverse: false,
                    hidden: false
                };
            }

            startCursorBlink() {
                setInterval(() => {
                    this.cursorBlink = !this.cursorBlink;
                    this.render();
                }, 530); // VT100 cursor blinks at ~1.875 Hz
            }

            /**
             * Write data to the terminal
             */
            write(data) {
                for (let i = 0; i < data.length; i++) {
                    const char = data[i];

                    if (this.parseState === 'normal') {
                        this.handleNormalChar(char);
                    } else if (this.parseState === 'escape') {
                        this.handleEscapeChar(char);
                    } else if (this.parseState === 'csi') {
                        this.handleCSIChar(char);
                    }
                }

                this.render();
            }

            handleNormalChar(char) {
                const code = char.charCodeAt(0);

                if (code === 27) { // ESC
                    this.parseState = 'escape';
                    this.escapeBuffer = '';
                } else if (code === 8) { // Backspace
                    if (this.cursorX > 0) {
                        this.cursorX--;
                    }
                } else if (code === 9) { // Tab
                    this.cursorX = Math.min(this.cols - 1, (Math.floor(this.cursorX / 8) + 1) * 8);
                } else if (code === 10) { // Line Feed
                    this.lineFeed();
                } else if (code === 13) { // Carriage Return
                    this.cursorX = 0;
                } else if (code === 7) { // Bell
                    // Beep sound (ignored in web)
                } else if (code >= 32 && code < 127) { // Printable ASCII
                    this.putChar(char);
                    this.cursorX++;
                    if (this.cursorX >= this.cols) {
                        this.cursorX = 0;
                        this.lineFeed();
                    }
                }
            }

            handleEscapeChar(char) {
                if (char === '[') {
                    this.parseState = 'csi';
                    this.escapeBuffer = '';
                } else if (char === 'M') {
                    // Reverse line feed
                    if (this.cursorY > this.scrollTop) {
                        this.cursorY--;
                    } else {
                        this.scrollDown();
                    }
                    this.parseState = 'normal';
                } else if (char === '7') {
                    // Save cursor
                    this.savedCursorX = this.cursorX;
                    this.savedCursorY = this.cursorY;
                    this.parseState = 'normal';
                } else if (char === '8') {
                    // Restore cursor
                    this.cursorX = this.savedCursorX;
                    this.cursorY = this.savedCursorY;
                    this.parseState = 'normal';
                } else if (char === 'c') {
                    // Reset terminal
                    this.reset();
                    this.parseState = 'normal';
                } else {
                    this.parseState = 'normal';
                }
            }

            handleCSIChar(char) {
                const code = char.charCodeAt(0);

                if ((code >= 48 && code <= 57) || char === ';' || char === '?') {
                    // Parameter character
                    this.escapeBuffer += char;
                } else {
                    // Command character
                    this.executeCSI(this.escapeBuffer, char);
                    this.parseState = 'normal';
                }
            }

            executeCSI(params, command) {
                const args = params.split(';').map(x => parseInt(x) || 0);

                switch (command) {
                    case 'A': // Cursor Up
                        this.cursorY = Math.max(this.scrollTop, this.cursorY - (args[0] || 1));
                        break;
                    case 'B': // Cursor Down
                        this.cursorY = Math.min(this.scrollBottom, this.cursorY + (args[0] || 1));
                        break;
                    case 'C': // Cursor Forward
                        this.cursorX = Math.min(this.cols - 1, this.cursorX + (args[0] || 1));
                        break;
                    case 'D': // Cursor Back
                        this.cursorX = Math.max(0, this.cursorX - (args[0] || 1));
                        break;
                    case 'H': // Cursor Position
                    case 'f':
                        this.cursorY = Math.min(this.rows - 1, Math.max(0, (args[0] || 1) - 1));
                        this.cursorX = Math.min(this.cols - 1, Math.max(0, (args[1] || 1) - 1));
                        break;
                    case 'J': // Erase in Display
                        this.eraseDisplay(args[0] || 0);
                        break;
                    case 'K': // Erase in Line
                        this.eraseLine(args[0] || 0);
                        break;
                    case 'm': // Select Graphic Rendition
                        this.setGraphicRendition(args);
                        break;
                    case 'r': // Set Scrolling Region
                        this.scrollTop = Math.max(0, (args[0] || 1) - 1);
                        this.scrollBottom = Math.min(this.rows - 1, (args[1] || this.rows) - 1);
                        break;
                    case 's': // Save cursor position
                        this.savedCursorX = this.cursorX;
                        this.savedCursorY = this.cursorY;
                        break;
                    case 'u': // Restore cursor position
                        this.cursorX = this.savedCursorX;
                        this.cursorY = this.savedCursorY;
                        break;
                    case 'l': // Reset Mode
                        if (params === '?25') {
                            this.cursorVisible = false;
                        }
                        break;
                    case 'h': // Set Mode
                        if (params === '?25') {
                            this.cursorVisible = true;
                        }
                        break;
                }
            }

            setGraphicRendition(args) {
                if (args.length === 0 || args[0] === 0) {
                    this.currentStyle = this.defaultStyle();
                    return;
                }

                for (let i = 0; i < args.length; i++) {
                    const arg = args[i];

                    if (arg === 0) {
                        this.currentStyle = this.defaultStyle();
                    } else if (arg === 1) {
                        this.currentStyle.bold = true;
                    } else if (arg === 2) {
                        this.currentStyle.dim = true;
                    } else if (arg === 4) {
                        this.currentStyle.underline = true;
                    } else if (arg === 5) {
                        this.currentStyle.blink = true;
                    } else if (arg === 7) {
                        this.currentStyle.reverse = true;
                    } else if (arg === 8) {
                        this.currentStyle.hidden = true;
                    } else if (arg === 22) {
                        this.currentStyle.bold = false;
                        this.currentStyle.dim = false;
                    } else if (arg === 24) {
                        this.currentStyle.underline = false;
                    } else if (arg === 25) {
                        this.currentStyle.blink = false;
                    } else if (arg === 27) {
                        this.currentStyle.reverse = false;
                    } else if (arg === 28) {
                        this.currentStyle.hidden = false;
                    } else if (arg >= 30 && arg <= 37) {
                        // Foreground colors
                        const colors = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
                        this.currentStyle.fg = colors[arg - 30];
                    } else if (arg >= 40 && arg <= 47) {
                        // Background colors
                        const colors = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
                        this.currentStyle.bg = colors[arg - 40];
                    } else if (arg >= 90 && arg <= 97) {
                        // Bright foreground colors
                        const colors = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
                        this.currentStyle.fg = 'bright-' + colors[arg - 90];
                    } else if (arg >= 100 && arg <= 107) {
                        // Bright background colors
                        const colors = ['black', 'red', 'green', 'yellow', 'blue', 'magenta', 'cyan', 'white'];
                        this.currentStyle.bg = 'bright-' + colors[arg - 100];
                    }
                }
            }

            eraseDisplay(mode) {
                if (mode === 0) { // Erase from cursor to end
                    this.eraseLine(0);
                    for (let y = this.cursorY + 1; y < this.rows; y++) {
                        for (let x = 0; x < this.cols; x++) {
                            this.buffer[y][x] = { char: ' ', style: this.defaultStyle() };
                        }
                    }
                } else if (mode === 1) { // Erase from start to cursor
                    this.eraseLine(1);
                    for (let y = 0; y < this.cursorY; y++) {
                        for (let x = 0; x < this.cols; x++) {
                            this.buffer[y][x] = { char: ' ', style: this.defaultStyle() };
                        }
                    }
                } else if (mode === 2) { // Erase entire display
                    for (let y = 0; y < this.rows; y++) {
                        for (let x = 0; x < this.cols; x++) {
                            this.buffer[y][x] = { char: ' ', style: this.defaultStyle() };
                        }
                    }
                }
            }

            eraseLine(mode) {
                if (mode === 0) { // Erase from cursor to end of line
                    for (let x = this.cursorX; x < this.cols; x++) {
                        this.buffer[this.cursorY][x] = { char: ' ', style: this.defaultStyle() };
                    }
                } else if (mode === 1) { // Erase from start of line to cursor
                    for (let x = 0; x <= this.cursorX; x++) {
                        this.buffer[this.cursorY][x] = { char: ' ', style: this.defaultStyle() };
                    }
                } else if (mode === 2) { // Erase entire line
                    for (let x = 0; x < this.cols; x++) {
                        this.buffer[this.cursorY][x] = { char: ' ', style: this.defaultStyle() };
                    }
                }
            }

            putChar(char) {
                this.buffer[this.cursorY][this.cursorX] = {
                    char: char,
                    style: Object.assign({}, this.currentStyle)
                };
            }

            lineFeed() {
                if (this.cursorY >= this.scrollBottom) {
                    this.scrollUp();
                } else {
                    this.cursorY++;
                }
            }

            scrollUp() {
                // Move lines up
                for (let y = this.scrollTop; y < this.scrollBottom; y++) {
                    this.buffer[y] = this.buffer[y + 1];
                }
                // Clear bottom line
                this.buffer[this.scrollBottom] = [];
                for (let x = 0; x < this.cols; x++) {
                    this.buffer[this.scrollBottom][x] = { char: ' ', style: this.defaultStyle() };
                }
            }

            scrollDown() {
                // Move lines down
                for (let y = this.scrollBottom; y > this.scrollTop; y--) {
                    this.buffer[y] = this.buffer[y - 1];
                }
                // Clear top line
                this.buffer[this.scrollTop] = [];
                for (let x = 0; x < this.cols; x++) {
                    this.buffer[this.scrollTop][x] = { char: ' ', style: this.defaultStyle() };
                }
            }

            reset() {
                this.cursorX = 0;
                this.cursorY = 0;
                this.scrollTop = 0;
                this.scrollBottom = this.rows - 1;
                this.currentStyle = this.defaultStyle();
                this.eraseDisplay(2);
            }

            /**
             * Render the terminal to the DOM
             */
            render() {
                let html = '';

                for (let y = 0; y < this.rows; y++) {
                    for (let x = 0; x < this.cols; x++) {
                        const cell = this.buffer[y][x];
                        const isCursor = (x === this.cursorX && y === this.cursorY && this.cursorVisible && this.cursorBlink);

                        let char = cell.char;
                        let classes = [];
                        let style = cell.style;

                        // Apply text styles
                        if (style.fg !== 'green') classes.push('ansi-' + style.fg);
                        if (style.bg !== 'black') classes.push('ansi-bg-' + style.bg);
                        if (style.bold) classes.push('ansi-bold');
                        if (style.dim) classes.push('ansi-dim');
                        if (style.underline) classes.push('ansi-underline');
                        if (style.blink) classes.push('ansi-blink');
                        if (style.reverse) classes.push('ansi-reverse');
                        if (style.hidden) classes.push('ansi-hidden');

                        if (isCursor) {
                            classes.push('cursor-block');
                        }

                        if (classes.length > 0) {
                            html += '<span class="' + classes.join(' ') + '">' + (char === ' ' && isCursor ? ' ' : char) + '</span>';
                        } else {
                            html += char;
                        }
                    }
                    if (y < this.rows - 1) {
                        html += '\n';
                    }
                }

                this.container.innerHTML = html;
            }

            resize(cols, rows) {
                // TODO: Implement terminal resizing
                this.cols = cols;
                this.rows = rows;
            }
        }

        /**
         * Skull Animation System
         * Creates a spectacular animation where terminal characters fly around
         * and form a skull in the center of the screen
         */
        class SkullAnimation {
            constructor(terminal) {
                this.terminal = terminal;
                this.overlay = document.getElementById('animation-overlay');
                this.isRunning = false;
                this.characters = [];
                this.savedBuffer = null;

                // Skull ASCII art (centered, approximately 20 lines)
                this.skullArt = [
                    "                    _______________                    ",
                    "                 .-'    _____    `-.                   ",
                    "              .'      .'     `.      `.                ",
                    "            .'      .'         `.      `.              ",
                    "           /       /   .     .   \\       \\            ",
                    "          /       /    |     |    \\       \\           ",
                    "         ;       ;    .'     `.    ;       ;           ",
                    "        ;        ;   /  o   o  \\   ;        ;          ",
                    "        |        |  ;           ;  |        |          ",
                    "        |        |  |           |  |        |          ",
                    "        |        |  |  .------.  |  |        |         ",
                    "        ;        ;  | (  ----  ) |  ;        ;         ",
                    "         ;       ;  |  `------'  |  ;       ;          ",
                    "         \\       \\  \\   _____   /  /       /          ",
                    "          \\       \\  `._____.'  /       /            ",
                    "           `.      `.           .'      .'             ",
                    "             `.      `.       .'      .'               ",
                    "               `-.     `-----'     .-'                 ",
                    "                  `---------------'                    "
                ];
            }

            /**
             * Start the skull animation
             */
            async start() {
                if (this.isRunning) return;

                this.isRunning = true;
                console.log('Starting skull animation...');

                // Save current terminal state
                this.saveTerminalState();

                // Phase 1: Extract and create flying characters (2s)
                await this.extractCharacters();

                // Phase 2: Wild flying animation (3s)
                await this.wildFlyingPhase();

                // Phase 3: Form skull (2s)
                await this.formSkullPhase();

                // Phase 4: Hold skull (10s)
                await this.holdSkullPhase();

                // Phase 5: Disintegrate (2s)
                await this.disintegratePhase();

                // Phase 6: Return to original positions (2s)
                await this.returnToOriginalPhase();

                // Phase 7: Cleanup and restore
                this.cleanup();

                this.isRunning = false;
                console.log('Skull animation completed');
            }

            /**
             * Save the current terminal buffer
             */
            saveTerminalState() {
                this.savedBuffer = [];
                for (let y = 0; y < this.terminal.rows; y++) {
                    this.savedBuffer[y] = [];
                    for (let x = 0; x < this.terminal.cols; x++) {
                        this.savedBuffer[y][x] = Object.assign({}, this.terminal.buffer[y][x]);
                    }
                }
            }

            /**
             * Extract all characters from terminal and create animated elements
             */
            async extractCharacters() {
                this.characters = [];
                const terminalRect = this.terminal.container.getBoundingClientRect();

                // Calculate character dimensions
                const charWidth = terminalRect.width / this.terminal.cols;
                const charHeight = terminalRect.height / this.terminal.rows;

                // Extract each character
                for (let y = 0; y < this.terminal.rows; y++) {
                    for (let x = 0; x < this.terminal.cols; x++) {
                        const cell = this.terminal.buffer[y][x];

                        // Skip empty spaces (but keep some for effect)
                        if (cell.char === ' ' && Math.random() > 0.1) continue;

                        // Create animated character element
                        const charEl = document.createElement('span');
                        charEl.className = 'flying-char';
                        charEl.textContent = cell.char;

                        // Apply styles
                        if (cell.style.fg !== 'green') {
                            charEl.style.color = this.getColorValue(cell.style.fg);
                        }
                        if (cell.style.bold) {
                            charEl.style.fontWeight = 'bold';
                        }

                        // Calculate position
                        const originalX = terminalRect.left + (x * charWidth);
                        const originalY = terminalRect.top + (y * charHeight);

                        charEl.style.left = originalX + 'px';
                        charEl.style.top = originalY + 'px';

                        // Store character data
                        this.characters.push({
                            element: charEl,
                            originalX: originalX,
                            originalY: originalY,
                            currentX: originalX,
                            currentY: originalY,
                            char: cell.char,
                            terminalX: x,
                            terminalY: y
                        });

                        // Add to overlay
                        this.overlay.appendChild(charEl);
                    }
                }

                // Small delay to let DOM update
                await this.delay(100);
            }

            /**
             * Phase 1: Characters fly around wildly
             */
            async wildFlyingPhase() {
                console.log('Wild flying phase...');

                // Make characters fly to random positions
                this.characters.forEach(char => {
                    char.element.classList.add('wild');

                    // Random velocity for each character
                    const vx = (Math.random() - 0.5) * 1000;
                    const vy = (Math.random() - 0.5) * 1000;

                    // Animate over 3 seconds
                    const animate = () => {
                        const newX = char.currentX + vx * 0.016; // 60fps
                        const newY = char.currentY + vy * 0.016;

                        // Wrap around screen edges
                        char.currentX = (newX + window.innerWidth) % window.innerWidth;
                        char.currentY = (newY + window.innerHeight) % window.innerHeight;

                        char.element.style.left = char.currentX + 'px';
                        char.element.style.top = char.currentY + 'px';
                    };

                    // Store animation interval
                    char.flyInterval = setInterval(animate, 16);
                });

                await this.delay(3000);

                // Stop wild flying
                this.characters.forEach(char => {
                    clearInterval(char.flyInterval);
                    char.element.classList.remove('wild');
                });
            }

            /**
             * Phase 2: Form skull in the center
             */
            async formSkullPhase() {
                console.log('Forming skull...');

                // Calculate skull position (centered on screen)
                const skullWidth = 56; // Width of skull art
                const skullHeight = this.skullArt.length;

                const screenCenterX = window.innerWidth / 2;
                const screenCenterY = window.innerHeight / 2;

                const charWidth = 9.6; // Approximate character width in pixels
                const charHeight = 19.2; // Approximate character height in pixels

                const skullStartX = screenCenterX - (skullWidth * charWidth / 2);
                const skullStartY = screenCenterY - (skullHeight * charHeight / 2);

                // Collect all skull characters
                const skullChars = [];
                for (let y = 0; y < this.skullArt.length; y++) {
                    for (let x = 0; x < this.skullArt[y].length; x++) {
                        const char = this.skullArt[y][x];
                        if (char !== ' ') {
                            skullChars.push({
                                char: char,
                                x: skullStartX + (x * charWidth),
                                y: skullStartY + (y * charHeight)
                            });
                        }
                    }
                }

                // Assign each flying character to a skull position
                this.characters.forEach((char, index) => {
                    char.element.classList.add('forming');

                    // Assign to skull position (cycle through if more chars than skull positions)
                    const skullPos = skullChars[index % skullChars.length];

                    char.targetX = skullPos.x;
                    char.targetY = skullPos.y;
                    char.element.textContent = skullPos.char;

                    // Animate to position
                    char.element.style.left = char.targetX + 'px';
                    char.element.style.top = char.targetY + 'px';
                });

                await this.delay(2000);
            }

            /**
             * Phase 3: Hold skull for 10 seconds
             */
            async holdSkullPhase() {
                console.log('Holding skull...');
                await this.delay(10000);
            }

            /**
             * Phase 4: Disintegrate the skull
             */
            async disintegratePhase() {
                console.log('Disintegrating...');

                // Remove forming class and make characters fly apart again
                this.characters.forEach(char => {
                    char.element.classList.remove('forming');
                    char.element.classList.add('wild');

                    // Random velocity away from center
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;

                    const dx = char.targetX - centerX;
                    const dy = char.targetY - centerY;

                    const angle = Math.atan2(dy, dx);
                    const speed = 500;

                    const vx = Math.cos(angle) * speed;
                    const vy = Math.sin(angle) * speed;

                    // Animate explosion
                    const animate = () => {
                        char.currentX = char.currentX + vx * 0.016;
                        char.currentY = char.currentY + vy * 0.016;

                        char.element.style.left = char.currentX + 'px';
                        char.element.style.top = char.currentY + 'px';
                    };

                    char.currentX = char.targetX;
                    char.currentY = char.targetY;
                    char.explodeInterval = setInterval(animate, 16);
                });

                await this.delay(2000);

                // Stop explosion
                this.characters.forEach(char => {
                    clearInterval(char.explodeInterval);
                    char.element.classList.remove('wild');
                });
            }

            /**
             * Phase 5: Return to original positions
             */
            async returnToOriginalPhase() {
                console.log('Returning to original positions...');

                this.characters.forEach(char => {
                    char.element.classList.add('returning');

                    // Restore original character
                    const originalCell = this.savedBuffer[char.terminalY][char.terminalX];
                    char.element.textContent = originalCell.char;

                    // Animate back to original position
                    char.element.style.left = char.originalX + 'px';
                    char.element.style.top = char.originalY + 'px';
                });

                await this.delay(2000);
            }

            /**
             * Cleanup and restore terminal
             */
            cleanup() {
                console.log('Cleaning up...');

                // Remove all character elements
                this.characters.forEach(char => {
                    char.element.remove();
                });

                this.characters = [];

                // Restore terminal buffer
                if (this.savedBuffer) {
                    for (let y = 0; y < this.terminal.rows; y++) {
                        for (let x = 0; x < this.terminal.cols; x++) {
                            this.terminal.buffer[y][x] = this.savedBuffer[y][x];
                        }
                    }
                    this.terminal.render();
                }
            }

            /**
             * Get CSS color value from ANSI color name
             */
            getColorValue(colorName) {
                const colors = {
                    'black': '#000000',
                    'red': '#ff0000',
                    'green': '#00ff00',
                    'yellow': '#ffff00',
                    'blue': '#0000ff',
                    'magenta': '#ff00ff',
                    'cyan': '#00ffff',
                    'white': '#ffffff',
                    'bright-black': '#555555',
                    'bright-red': '#ff5555',
                    'bright-green': '#55ff55',
                    'bright-yellow': '#ffff55',
                    'bright-blue': '#5555ff',
                    'bright-magenta': '#ff55ff',
                    'bright-cyan': '#55ffff',
                    'bright-white': '#ffffff'
                };
                return colors[colorName] || '#00ff00';
            }

            /**
             * Delay helper
             */
            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }
        }

        // Initialize terminal
        const terminalScreen = document.getElementById('terminal-screen');
        const statusEl = document.getElementById('status');
        const loadingEl = document.getElementById('loading');
        const hiddenInput = document.getElementById('hidden-input');

        const terminal = new VT100Terminal(terminalScreen);

        // Initialize skull animation
        const skullAnimation = new SkullAnimation(terminal);

        // Easter egg trigger: Triple ESC press within 1 second
        let escPressCount = 0;
        let escPressTimer = null;

        function handleEscapePress() {
            escPressCount++;
            if (escPressCount === 3) {
                console.log('üíÄ Triple ESC detected - triggering skull animation!');
                if (!skullAnimation.isRunning) {
                    skullAnimation.start();
                }
                escPressCount = 0;
                clearTimeout(escPressTimer);
            } else {
                clearTimeout(escPressTimer);
                escPressTimer = setTimeout(() => {
                    escPressCount = 0;
                }, 1000);
            }
        }

        // Update status
        function setStatus(status, text) {
            statusEl.className = status;
            statusEl.textContent = text;
        }

        // Socket.IO connection
        const socket = io({
            transports: ['websocket', 'polling'],
            upgrade: true
        });

        // Connection events
        socket.on('connect', () => {
            console.log('Connected to server');
            setStatus('connected', '‚óè Connected');
        });

        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            setStatus('disconnected', '‚óã Disconnected');
            terminal.write('\r\n\r\n=== Connection lost. Please refresh the page. ===\r\n');
        });

        socket.on('connected', (data) => {
            console.log('Server response:', data.data);
        });

        // Output handling
        let firstOutput = true;
        socket.on('output', (data) => {
            terminal.write(data.data);

            // Hide loading screen on first output
            if (firstOutput) {
                firstOutput = false;
                setTimeout(() => {
                    loadingEl.classList.add('hidden');
                    terminalScreen.focus();
                }, 100);
            }
        });

        // Keyboard input handling
        terminalScreen.addEventListener('keydown', (e) => {
            // Check for skull animation trigger (multiple options for compatibility)
            // Ctrl+Shift+K or Ctrl+Alt+S (Skull)
            const isSkullShortcut = (
                (e.ctrlKey && e.shiftKey && (e.key === 'K' || e.key === 'k' || e.keyCode === 75)) ||
                (e.ctrlKey && e.altKey && (e.key === 'S' || e.key === 's' || e.keyCode === 83))
            );

            if (isSkullShortcut) {
                e.preventDefault();
                e.stopPropagation();
                if (!skullAnimation.isRunning) {
                    console.log('üíÄ Skull animation triggered!');
                    skullAnimation.start();
                } else {
                    console.log('‚ö†Ô∏è Animation already running...');
                }
                return;
            }

            let data = null;

            // Prevent default for most keys
            e.preventDefault();

            if (e.key === 'Enter') {
                data = '\r';
            } else if (e.key === 'Backspace') {
                data = '\x7f'; // DEL character
            } else if (e.key === 'Tab') {
                data = '\t';
            } else if (e.key === 'Escape') {
                handleEscapePress(); // Check for triple ESC easter egg
                data = '\x1b';
            } else if (e.key === 'ArrowUp') {
                data = '\x1b[A';
            } else if (e.key === 'ArrowDown') {
                data = '\x1b[B';
            } else if (e.key === 'ArrowRight') {
                data = '\x1b[C';
            } else if (e.key === 'ArrowLeft') {
                data = '\x1b[D';
            } else if (e.key === 'Home') {
                data = '\x1b[H';
            } else if (e.key === 'End') {
                data = '\x1b[F';
            } else if (e.key === 'Delete') {
                data = '\x1b[3~';
            } else if (e.key === 'Insert') {
                data = '\x1b[2~';
            } else if (e.key === 'PageUp') {
                data = '\x1b[5~';
            } else if (e.key === 'PageDown') {
                data = '\x1b[6~';
            } else if (e.ctrlKey && e.key === 'c') {
                data = '\x03'; // Ctrl+C
            } else if (e.ctrlKey && e.key === 'd') {
                data = '\x04'; // Ctrl+D
            } else if (e.ctrlKey && e.key === 'z') {
                data = '\x1a'; // Ctrl+Z
            } else if (e.ctrlKey && e.key === 'l') {
                data = '\x0c'; // Ctrl+L
            } else if (e.key.length === 1 && !e.ctrlKey && !e.altKey && !e.metaKey) {
                data = e.key;
            }

            if (data) {
                socket.emit('input', { data: data });
            }
        });

        // Focus terminal on click
        document.addEventListener('click', () => {
            terminalScreen.focus();
        });

        // Focus terminal on load
        window.addEventListener('load', () => {
            terminalScreen.focus();
        });

        // Prevent context menu
        document.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });

        console.log('VT100 Terminal Emulator initialized');
        console.log('80x24 character display');
        console.log('Full ANSI escape sequence support');
        console.log('üíÄ Secret Easter Egg: Press Ctrl+Shift+K, Ctrl+Alt+S, or ESC 3 times for a special animation!');
    </script>
</body>
</html>
